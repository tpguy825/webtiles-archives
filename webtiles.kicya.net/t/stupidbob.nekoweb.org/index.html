<html lang="en">
<head>
    <style>* {
  font-family: monospace;
}

.tile-body {
  color: #111;
  background-color: #f0f0f0;
  display: flex;
}

canvas1, canvas2 {
  position: fixed;
}

#textfield {
  text-align: center;
  opacity: 1;
  border: none;
  width: 1px;
  height: 1px;
  position: absolute;
}

::placeholder {
  color: #fff;
}

input:focus {
  box-shadow: none;
  outline: none;
}

#overlayText {
  z-index: 999;
  color: #9acd32;
  background: #0009;
  padding: 6px 10px;
  font-size: 9px;
  position: fixed;
}

#overlayText.collapsed {
  width: 20px;
}

#border-top {
  content: "";
  z-index: 10;
  border-left: 4px;
  border-image: url("durkaborder.png") 28 / 28px round;
  width: 120%;
  height: 14px;
  position: absolute;
  top: -4px;
  left: -10px;
}

#inputr {
  z-index: 9;
  color: red;
  pointer-events: none;
  background: #0009;
  padding: 6px 10px;
  font-size: 9px;
  position: absolute;
  top: 200px;
}

#fps {
  z-index: 9;
  color: #add8e6;
  background: #0009;
  padding: 6px 10px;
  font-size: 9px;
  position: absolute;
  top: 200px;
  left: 200px;
}
</style>
    <img src="sky.jpg" style="display:none" id="skytexture">
    <img src="purplestone.jpg" style="display:none" id="walltexture">
</head>
<body>
    <p id="overlayText"><u>3D raycasting engine!!!!</u><br>You have to press once more to enable input.<br>Use WASD and arrows to move and look around.
        <br><span style="color:yellow;">click on this to remove the text</span></p>
    

    <canvas id="canvas1" width="250" height="250"></canvas>
    <canvas id="canvas2" width="250" height="250"></canvas>
    <input id="textfield" autocomplete="off"><br>
    <div id="border-top"></div>
    
    <p id="inputr">
        not receiving input
    </p>
    
	<p id="fps">
        FPS: 0
    </p>
    <script type="text/tilescript">// =====================
// globals
// =====================
var frames = 0;
var fps = 0;
var maxRays = 24;
var lastFpsTime = Date.now();

var W = 250;
var H = 250;

var DEG = 360;

var sinLUT = new Array(DEG);
var cosLUT = new Array(DEG);
var invSinLUT = new Array(DEG);
var invCosLUT = new Array(DEG);

function abs(x) { return x < 0 ? -x : x; }

// normalize any integer angle to [0..359]
function normAng(a) {
  a = a | 0;
  a %= 360;
  return a < 0 ? a + 360 : a;
}

function precomputeTrig() {
  for (var i = 0; i < DEG; i++) {
    var rad = i * Math.PI / 180;
    var s = Math.sin(rad);
    var c = Math.cos(rad);

    sinLUT[i] = s;
    cosLUT[i] = c;

    invSinLUT[i] = abs(s) < 1e-6 ? (s < 0 ? -1e6 : 1e6) : 1 / s;
    invCosLUT[i] = abs(c) < 1e-6 ? (c < 0 ? -1e6 : 1e6) : 1 / c;
  }
}

// =====================
// canvases + contexts (double buffer)
// =====================
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');

canvas.width = W;
canvas.height = H;

// offscreen back buffer (NOT in DOM)
var back = document.createElement('canvas');
back.width = W;
back.height = H;
var bctx = back.getContext('2d');

// =====================
// sky pattern (wait for load)
// =====================
var skyPattern = null;
var skyImg = document.getElementById("skytexture");
if (skyImg) {
  if (skyImg.complete && skyImg.naturalWidth) {
    skyPattern = backCtx.createPattern(skyImg, "repeat");
  } else {
    skyImg.onload = function() {
      // create pattern on BOTH contexts so it works regardless of which is back buffer
      skyPattern = ctx.createPattern(skyImg, "repeat");
    };
  }
}

// =====================
// simple procedural wall texture
// =====================
function makeBrickTexture(w, h) {
  var c = document.createElement('canvas');
  c.width = w; c.height = h;
  var g = c.getContext('2d');

  var brickW = 16, brickH = 8, mortar = 1;

  g.fillStyle = 'darkred';
  g.fillRect(0, 0, w, h);

  g.fillStyle = 'rgb(25, 0, 0)';
  for (var y = 0; y < h; y += brickH) {
    var offset = (((y / brickH) | 0) & 1) ? (brickW >> 1) : 0;
    for (var x = -offset; x < w; x += brickW) {
      g.fillRect(x + mortar, y + mortar, brickW - 2 * mortar, brickH - 2 * mortar);
    }
  }
  return c;
}

var wallImg = makeBrickTexture(16, 24);

// =====================
// overlay
// =====================
var overlay = document.getElementById('overlayText');
if (overlay) {
  overlay.onclick = function() { overlay.style.display = 'none'; };
}

// =====================
// world + player
// =====================
var emptyTile = '.';

function World(width, height, map) {
  this.width = width;
  this.height = height;
  this.map = map;

  // tiles in pixels
  this.tileX = W / width;
  this.tileY = H / height;
}

function Player(x, y, angle, speed, size, world) {
  this.x = x;
  this.y = y;

  this.angle = normAng(angle); // int degrees 0..359

  this.speed = speed;
  this.size = size;

  this.sinA = 0;
  this.cosA = 1;

  this.FOV = 30; // degrees
  this.world = world;
}

Player.prototype.update = function() {
  // keep angle int + normalized
  this.angle = normAng(this.angle);

  // cache forward vector from LUT
  this.sinA = sinLUT[this.angle];
  this.cosA = cosLUT[this.angle]

  // movement
  if (keys[0]) { // W
    this.x += this.speed * this.cosA;
    this.y += this.speed * this.sinA;
  }
  if (keys[2]) { // S
    this.x -= this.speed * this.cosA;
    this.y -= this.speed * this.sinA;
  }
  if (keys[1]) { // A (strafe left)
    this.x += this.speed * this.sinA;
    this.y -= this.speed * this.cosA;
  }
  if (keys[3]) { // D (strafe right)
    this.x -= this.speed * this.sinA;
    this.y += this.speed * this.cosA;
  }

  // rotation
  if (keys[4]) this.angle = normAng(this.angle - 10);
  if (keys[5]) this.angle = normAng(this.angle + 10);
};

// DDA raycast using LUT (still returns object; we can optimize later)
Player.prototype.castRay = function(aDeg) {
  aDeg = normAng(aDeg);

  var sin = sinLUT[aDeg];
  var cos = cosLUT[aDeg];

  // use precomputed reciprocals (avoid divisions)
  var invCos = invCosLUT[aDeg];
  var invSin = invSinLUT[aDeg];

  // player position in tile units
  var px = this.x / this.world.tileX;
  var py = this.y / this.world.tileY;

  var mx = px | 0;
  var my = py | 0;

  var dx = abs(invCos);
  var dy = abs(invSin);

  var sx = (cos < 0) ? -1 : 1;
  var sy = (sin < 0) ? -1 : 1;

  var rx = ((sx < 0) ? (px - mx) : (mx + 1 - px)) * dx;
  var ry = ((sy < 0) ? (py - my) : (my + 1 - py)) * dy;

  var side = 0;
  var tile = emptyTile;

  // cap steps (render distance could be used here too)
  var steps = 0;
  var maxSteps = this.world.width * this.world.height + 64;

  while (steps++ < maxSteps) {
    if (rx < ry) { rx += dx; mx += sx; side = 0; }
    else         { ry += dy; my += sy; side = 1; }

    if (my < 0 || my >= this.world.height || mx < 0 || mx >= this.world.width) {
      return { dist: 1e6, texX: 0, side: side, tile: false };
    }

    tile = this.world.map[my][mx];
    if (tile !== emptyTile) break;
  }

  // distance in tile units (use reciprocal already)
  var distTiles = (side === 0)
    ? (mx - px + (1 - sx) / 2) * invCos
    : (my - py + (1 - sy) / 2) * invSin;

  var dist = distTiles * this.world.tileX;

  // texture coordinate along wall (0..1)
  var hit = (side === 0) ? (py + distTiles * sin) : (px + distTiles * cos);
  hit -= Math.floor(hit);

  return { dist: dist, texX: hit, side: side, tile: tile };
};

// =====================
// input
// =====================
var textfield = document.getElementById('textfield');
var inputr = document.getElementById('inputr');

function focusInput() { if (textfield) textfield.focus(); }
canvas.onclick = focusInput;

if (textfield && inputr) {
  textfield.addEventListener('focus', function() {
    inputr.innerText = 'receiving input';
    inputr.style.color = 'green';
  });
  textfield.addEventListener('blur', function() {
    inputr.innerText = 'not receiving input';
    inputr.style.color = 'red';
  });
}

var keys = [false, false, false, false, false, false];
var controls = ['w', 'a', 's', 'd', 'ArrowLeft', 'ArrowRight'];

function onKeyDown(e) {
  for (var i = 0; i < 6; i++) if (e.key === controls[i]) keys[i] = true;
}
function onKeyUp(e) {
  for (var i = 0; i < 6; i++) if (e.key === controls[i]) keys[i] = false;
}

if (textfield) {
  textfield.addEventListener('keydown', onKeyDown, true);
  textfield.addEventListener('keyup', onKeyUp, true);
}

// =====================
// map + init
// =====================
var map1 = [
  '##########',
  '#........#',
  '#.#r..g#.#',
  '#.b....r.#',
  '#........#',
  '#........#',
  '#.r....y.#',
  '#.gg..rg.#',
  '#........#',
  '##########'
];

var world = new World(10, 10, map1);
var player = new Player(125, 125, 90, 5, 10, world);

var efps = document.getElementById('fps');

precomputeTrig();

// =====================
// rendering
// =====================
function drawFrame(player, ctx) {
  var HALF_H = (H >> 1);

  // sky
  if (skyPattern) {
    var shift = (player.angle / 360) * W * 2;
    ctx.save();
    ctx.translate(-shift, 0);
    ctx.fillStyle = skyPattern;
    ctx.fillRect(0, 0, W * 3, HALF_H);
    ctx.restore();
  } else {
    ctx.fillStyle = "#333";
    ctx.fillRect(0, 0, W, HALF_H);
  }

  // floor
  ctx.fillStyle = "rgb(0, 25, 0)";
  ctx.fillRect(0, HALF_H, W, HALF_H);

  var RAYS = maxRays;
  var FOV = player.FOV;   // degrees
  var WALL_H = 30;

  var step = FOV / RAYS;

  // IMPORTANT: turn base into an INT ONCE
  // (rounding is fine; you're on a 360-entry LUT anyway)
  var a = normAng((player.angle - (FOV * 0.5) + (step * 0.5)) | 0);

  var imgW = wallImg.width;
  var imgH = wallImg.height;

  for (var i = 0; i < RAYS; i++) {
    // cast using INT degrees (no float rayAng)
    var r = player.castRay(a);
    if (r && r.tile && r.dist < 1e6) {

      // fish-eye correction: cos(a - player.angle) with NO normAng() / % inside loop
      var delta = a - player.angle;
      if (delta < 0) delta += 360; // now delta is 0..359

      var d = r.dist * cosLUT[delta];
      if (d < 0.0001) d = 0.0001;

      var h = (WALL_H * H / d) | 0;

      var x0 = (i * W / RAYS) | 0;
      var x1 = ((i + 1) * W / RAYS) | 0;
      var w = (x1 - x0) | 0;

      var u = r.texX;
      if (u < 0) u = 0;
      else if (u > 0.9999) u = 0.9999;

      var texX = (u * imgW) | 0;
      var y0 = (HALF_H - (h >> 1)) | 0;

      ctx.drawImage(wallImg, texX, 0, 1, imgH, x0, y0, w, h);

      if (r.side === 1) {
        ctx.fillStyle = "rgba(0,0,0,0.28)";
        ctx.fillRect(x0, y0, w, h);
      }
    }

    // HERE is the “no %360” wrap:
    a++;
    if (a === 360) a = 0;
  }
}


// =====================
// main loop
// =====================
function loop() {
  var now = Date.now();

  frames++;
  if (now - lastFpsTime >= 1000) {
    fps = frames;
    frames = 0;
    lastFpsTime = now;
    if (efps) efps.innerText = "FPS: " + fps;
  }

  // draw into BACK buffer
  drawFrame(player, bctx);
    
  ctx.drawImage(back, 0, 0)

  // update player
  player.update();

//   // present back buffer
//   swapBuffers();

  setTimeout(loop, 25);
}

loop();</script>
</body>
</html>	