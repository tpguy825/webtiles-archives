<html lang="en">
<head>
    <style>* {
  font-family: monospace;
}

.tile-body {
  color: #111;
  background-color: #f0f0f0;
  display: flex;
}

canvas1, canvas2 {
  position: fixed;
}

#textfield {
  text-align: center;
  opacity: 1;
  border: none;
  width: 1px;
  height: 1px;
  position: absolute;
}

::placeholder {
  color: #fff;
}

input:focus {
  box-shadow: none;
  outline: none;
}

#overlayText {
  z-index: 999;
  color: #9acd32;
  background: #0009;
  padding: 6px 10px;
  font-size: 9px;
  position: absolute;
  top: 180px;
}

#overlayText.collapsed {
  width: 20px;
}

#border-top {
  content: "";
  z-index: 10;
  border-left: 4px;
  border-image: url("durkaborder.png") 28 / 28px round;
  width: 120%;
  height: 14px;
  position: absolute;
  top: -4px;
  left: -10px;
}

#inputr {
  z-index: 9;
  color: #c83232;
  pointer-events: none;
  font-size: 12px;
  position: absolute;
  top: -5px;
  left: 120px;
}

#lsd {
  z-index: 9;
  pointer-events: none;
  font-size: 12px;
  position: absolute;
  top: 10px;
  left: 140px;
}

#info {
  z-index: 9;
  color: #ff0;
  margin-left: 5px;
  font-size: 12px;
  position: absolute;
  top: -5px;
}
</style>
    <img src="sky.jpg" style="display:none" id="skytexture">
    <img src="purplestone.jpg" style="display:none" id="walltexture">
</head>
<body>
    <p id="overlayText"><u>3D raycasting engine!!!!</u><br>You have to press once more to enable input.<br>Use WASD and arrows to move and look around.
        <br><span style="color:yellow;">click on this to remove the text</span></p>
    
	<img src="preview.png" id="preview">
    <canvas id="canvas1" width="250" height="250"></canvas>
    <canvas id="canvas2" width="250" height="250"></canvas>
    <input id="textfield" autocomplete="off"><br>
    <div id="border-top"></div>
    
    <p id="inputr">
        not receiving input
    </p>
    
	<p id="lsd" style="display:none" class="rainbow-text">
		LSD MODE ENABLED
    </p>
    
	<p id="info">
        FPS: 0<br>
        x: 125, y: 125<br>
        ang: 90
    </p>
    <script type="text/tilescript">// =====================
// globals
// =====================
var frames = 0;
var fps = 0;
var maxRays = 16;
var lastFpsTime = Date.now();

var W = 250;
var H = 250;

var DEG = 360;

var sinLUT = new Array(DEG);
var cosLUT = new Array(DEG);
var invSinLUT = new Array(DEG);
var invCosLUT = new Array(DEG);

function abs(x) { return x < 0 ? -x : x; }

// normalize any integer angle to [0..359]
function normAng(a) {
  a = a | 0;
  a %= 360;
  return a < 0 ? a + 360 : a;
}

function precomputeTrig() {
  for (var i = 0; i < DEG; i++) {
    var rad = i * Math.PI / 180;
    var s = Math.sin(rad);
    var c = Math.cos(rad);

    sinLUT[i] = s;
    cosLUT[i] = c;

    invSinLUT[i] = abs(s) < 1e-6 ? (s < 0 ? -1e6 : 1e6) : 1 / s;
    invCosLUT[i] = abs(c) < 1e-6 ? (c < 0 ? -1e6 : 1e6) : 1 / c;
  }
}

(function () {
  var el = document.getElementById('lsd');
  if (!el) return;

  var colors = ['#ff0000','#ff7f00','#ffff00','#00ff00','#00ffff','#0000ff','#8b00ff'];
  var text = el.innerText || el.textContent || '';

  el.innerText = '';

  for (var i = 0; i < text.length; i++) {
    var span = document.createElement('span');
    span.appendChild(document.createTextNode(text.charAt(i)));
    span.style.color = colors[i % colors.length];
    el.appendChild(span);
  }
})();

// =====================
// canvases + contexts 
// =====================
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');

canvas.width = W;
canvas.height = H;

var back = document.createElement('canvas');
back.width = W;
back.height = H;
var bctx = back.getContext('2d');

var preview = document.getElementById('preview');
preview.style.display = 'none';

// =====================
// sky pattern 
// =====================
var skyPattern = null;
var skyImg = document.getElementById("skytexture");
skyPattern = ctx.createPattern(skyImg, "repeat");

// =====================
// simple procedural wall texture
// =====================
function makeBrickTexture(w, h, color1, color2) {
  var c = document.createElement('canvas');
  c.width = w; c.height = h;
  var g = c.getContext('2d');

  var brickW = 16, brickH = 8, mortar = 1;

  g.fillStyle = color1;
  g.fillRect(0, 0, w, h);

  g.fillStyle = color2;
  for (var y = 0; y < h; y += brickH) {
    var offset = (((y / brickH) | 0) & 1) ? (brickW >> 1) : 0;
    for (var x = -offset; x < w; x += brickW) {
      g.fillRect(x + mortar, y + mortar, brickW - 2 * mortar, brickH - 2 * mortar);
    }
  }
  return c;
}

var redBrick = makeBrickTexture(16, 24, "darkred", "rgb(25, 0, 0)");
var greenBrick = makeBrickTexture(16, 24, "darkgreen", "rgb(0, 25, 0)");
var blueBrick = makeBrickTexture(16, 24, "darkblue", "rgb(0, 0, 25)");
var yellowBrick = makeBrickTexture(16, 24, "darkyellow", "rgb(25, 25, 0)");
var purpleBrick = makeBrickTexture(16, 24, "darkpurple", "rgb(0, 25, 25)");
var whiteBrick = makeBrickTexture(16, 24, "gray", "rgb(25, 25, 25)");

// =====================
// overlay
// =====================
var overlay = document.getElementById('overlayText');
if (overlay) {
  overlay.onclick = function() { overlay.style.display = 'none'; };
}

// =====================
// world + player
// =====================
var emptyTile = '.';

function World(width, height, map) {
  this.width = width;
  this.height = height;
  this.map = map;

  this.tileX = W / width;
  this.tileY = H / height;
}

function Player(x, y, angle, speed, size, world) {
  this.x = x;
  this.y = y;

  this.angle = normAng(angle);

  this.speed = speed;
  this.size = size;

  this.sinA = 0;
  this.cosA = 1;

  this.FOV = 45;
  this.world = world;
}

var lsdmode = false;
var textshown = false;
var lsd = document.getElementById('lsd');

Player.prototype.update = function() {
  this.angle = normAng(this.angle);

  this.sinA = sinLUT[this.angle];
  this.cosA = cosLUT[this.angle]

  if (keys[0]) { // W
    this.x += this.speed * this.cosA;
    this.y += this.speed * this.sinA;
  }
  if (keys[2]) { // S
    this.x -= this.speed * this.cosA;
    this.y -= this.speed * this.sinA;
  }
  if (keys[1]) { // A 
    this.x += this.speed * this.sinA;
    this.y -= this.speed * this.cosA;
  }
  if (keys[3]) { // D
    this.x -= this.speed * this.sinA;
    this.y += this.speed * this.cosA;
  }

  if (keys[4]) this.angle = normAng(this.angle - 10);
  if (keys[5]) this.angle = normAng(this.angle + 10);
    
  if (keys[6] && !lsdmode) lsdmode = true;
  else if (keys[6]) lsdmode = false;
    
  if (lsdmode) {
      lsd.style.display = 'block'
  }
  else {
      lsd.style.display = 'none';
  }
    
  this.x = Math.round(this.x * 10) / 10;
  this.y = Math.round(this.y * 10) / 10;
};

Player.prototype.castRay = function(aDeg) {
  aDeg = normAng(aDeg);

  var sin = sinLUT[aDeg];
  var cos = cosLUT[aDeg];

  var invCos = invCosLUT[aDeg];
  var invSin = invSinLUT[aDeg];

  var px = this.x / this.world.tileX;
  var py = this.y / this.world.tileY;

  var mx = px | 0;
  var my = py | 0;

  var dx = abs(invCos);
  var dy = abs(invSin);

  var sx = (cos < 0) ? -1 : 1;
  var sy = (sin < 0) ? -1 : 1;

  var rx = ((sx < 0) ? (px - mx) : (mx + 1 - px)) * dx;
  var ry = ((sy < 0) ? (py - my) : (my + 1 - py)) * dy;

  var side = 0;
  var tile = emptyTile;

  var steps = 0;
  var maxSteps = this.world.width * this.world.height + 64;

  var maxDistTiles = 15;

  while (steps++ < maxSteps) {
    if (rx < ry) { rx += dx; mx += sx; side = 0; }
    else         { ry += dy; my += sy; side = 1; }
    var traveled = (side === 0) ? (rx - dx) : (ry - dy);
    if (traveled > maxDistTiles) {
      return { dist: 200, texX: 10, side: side, tile: 'x' };
    }
    if (mx < 0 || my < 0 || mx >= this.world.width || my >= this.world.height) {
      tile = emptyTile;
      continue;
    }
    tile = this.world.map[my][mx];
    if (tile !== emptyTile) break;
  }
    
  var distTiles = (side === 0)
    ? (mx - px + (1 - sx) / 2) * invCos
    : (my - py + (1 - sy) / 2) * invSin;

  var dist = distTiles * this.world.tileX;

  var hit = (side === 0) ? (py + distTiles * sin) : (px + distTiles * cos);
  hit -= Math.floor(hit);

  return { dist: dist, texX: hit, side: side, tile: tile };
};

// =====================
// input
// =====================
var textfield = document.getElementById('textfield');
var inputr = document.getElementById('inputr');

function focusInput() { if (textfield) textfield.focus(); }
canvas.onclick = focusInput;

if (textfield && inputr) {
  textfield.addEventListener('focus', function() {
    inputr.innerText = 'receiving input';
    inputr.style.color = 'rgb(200, 255, 200)';
    inputr.style.left = '150px';
  });
  textfield.addEventListener('blur', function() {
    inputr.innerText = 'not receiving input';
    inputr.style.color = 'rgb(200, 50, 50)';
    inputr.style.left = '120px';
  });
}

var keys = [false, false, false, false, false, false, false];
var controls = ['w', 'a', 's', 'd', 'ArrowLeft', 'ArrowRight', 'f'];

function onKeyDown(e) {
  for (var i = 0; i < keys.length; i++) if (e.key === controls[i]) keys[i] = true;
}
function onKeyUp(e) {
  for (var i = 0; i < keys.length; i++) if (e.key === controls[i]) keys[i] = false;
}

if (textfield) {
  textfield.addEventListener('keydown', onKeyDown, true);
  textfield.addEventListener('keyup', onKeyUp, true);
}

// =====================
// map + init
// =====================
var map1 = [
  '##########',
  '#........#',
  '#.pr..gp.#',
  '#.b....r.#',
  '..........',
  '..........',
  '#.r....y.#',
  '#.gp..rg.#',
  '#........#',
  '##########'
];

var world = new World(10, 10, map1);
var player = new Player(125, 125, 90, 5, 10, world);

var info = document.getElementById('info');

precomputeTrig();

// =====================
// rendering
// =====================

var groundGrad = ctx.createLinearGradient(0, H>>1, 0, H);
groundGrad.addColorStop(0.0, "rgba(0,0,0,0.25)");
groundGrad.addColorStop(0.6, "rgba(0,0,0,0.55)");
groundGrad.addColorStop(1.0, "rgba(0,0,0,0.70)");

var skyFogGrad = ctx.createLinearGradient(0, 0, 0, H>>1);
skyFogGrad.addColorStop(0.00, "rgba(175,190,205,0.20)");
skyFogGrad.addColorStop(1.00, "rgba(175,190,205,0.75)");

var groundFogGrad = ctx.createLinearGradient(0, H, 0, H>>1);
groundFogGrad.addColorStop(0.00, "rgba(175,190,205,0.10)");
groundFogGrad.addColorStop(0.55, "rgba(175,190,205,0.25)");
groundFogGrad.addColorStop(1.00, "rgba(175,190,205,0.85)");

function drawHorizonFog(ctx) {
  var HALF_H = (H >> 1);
  var fogR = 175, fogG = 190, fogB = 205;

  ctx.fillStyle = skyFogGrad;
  ctx.fillRect(0, 0, W, HALF_H);

  ctx.fillStyle = groundFogGrad;
  ctx.fillRect(0, HALF_H, W, HALF_H);
}

function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }
function smooth01(t){ return t * t * (3 - 2 * t); }

ctx.globalAlpha = 1;
ctx.globalCompositeOperation = 'source-over';

function drawFrame(player, ctx) {
  var HALF_H = (H >> 1);
	
   if (!lsdmode) {
      if (skyPattern) {
        var shift = (player.angle / 360) * W * 2;
        ctx.save();
        ctx.translate(-shift, 0);
        ctx.fillStyle = skyPattern;
        ctx.fillRect(0, 0, W * 3, H);
        ctx.restore();
      } else {
        ctx.fillStyle = "#333";
        ctx.fillRect(0, 0, W, H);
      }

      ctx.fillStyle = groundGrad;
      ctx.fillRect(0, HALF_H, W, HALF_H);
  }
    
  drawHorizonFog(ctx);

  var RAYS = maxRays;
  var FOV = player.FOV;
  var WALL_H = 30;

  var step = FOV / RAYS;
  var base = player.angle - (FOV * 0.5) + (step * 0.5);
    
  var fogStart = 2 * player.world.tileX; 
  var fogEnd   = 15* player.world.tileX;
  var fogR = 120, fogG = 140, fogB = 160;   

  for (var i = 0; i < RAYS; i++) {
    var rayAng = base + i * step;
    var r = player.castRay(rayAng);

    if (!r || !r.tile || r.dist >= 1e6) continue;
      
	var img = null;
    var fogMult = 2.3;
      
   	if (r.tile == "r") img = redBrick;
    if (r.tile == "g") img = greenBrick;
    if (r.tile == "b") img = blueBrick;
    if (r.tile == "y") img = yellowBrick;
    if (r.tile == "p") img = purpleBrick;
    if (r.tile == "#") img = whiteBrick;
    if (r.tile == "x") continue;
      
    var imgW = img.width;
    var imgH = img.height;

    var corrAng = normAng((rayAng | 0) - player.angle);
    var d = r.dist * cosLUT[corrAng];
    if (d < 0.0001) d = 0.0001;

    var h = (WALL_H * H / d) | 0;

    var x0 = (i * W / RAYS) | 0;
    var x1 = ((i + 1) * W / RAYS) | 0;
    var w = (x1 - x0) | 0;

    var u = r.texX;
    if (u < 0) u = 0;
    else if (u > 0.9999) u = 0.9999;

    var texX = (u * imgW) | 0;
    var y0 = (HALF_H - (h >> 1)) | 0;

    ctx.drawImage(
      img,
      texX, 0, 1, imgH,
      x0, y0, w, h
    );

    var t = clamp01((r.dist - fogStart) / (fogEnd - fogStart));
      
    if (r.side === 1) {
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(x0, y0, w, h);
    }

    ctx.fillStyle = "rgba(" + fogR + "," + fogG + "," + fogB + "," + t*fogMult + ")";
    ctx.fillRect(x0, y0, w, h);
  }
}

// =====================
// main loop
// =====================
function loop() {
  var now = Date.now();

  frames++;
  if (now - lastFpsTime >= 1000) {
    fps = frames;
    frames = 0;
    lastFpsTime = now;
    if (info) {
        info.innerText = "FPS: " + fps + '\nx: ' + player.x + ', y: ' + player.y + '\nang: ' + player.angle;
    }
  }

  drawFrame(player, bctx);
    
  ctx.drawImage(back, 0, 0)
  player.update();
  setTimeout(loop, 50);
}

loop();</script>
</body>
</html>	