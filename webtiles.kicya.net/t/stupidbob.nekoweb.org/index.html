<html lang="en">
<head>
    <style>* {
  font-family: monospace;
}

.tile-body {
  color: #111;
  background-color: #f0f0f0;
  display: flex;
}

canvas1, canvas2 {
  position: fixed;
}

#textfield {
  text-align: center;
  opacity: 1;
  border: none;
  width: 1px;
  height: 1px;
  position: absolute;
}

::placeholder {
  color: #fff;
}

input:focus {
  box-shadow: none;
  outline: none;
}

#overlayText {
  z-index: 999;
  color: #9acd32;
  background: #0009;
  padding: 6px 10px;
  font-size: 9px;
  position: fixed;
}

#overlayText.collapsed {
  width: 20px;
}

#border-top {
  content: "";
  z-index: 10;
  border-left: 4px;
  border-image: url("durkaborder.png") 28 / 28px round;
  width: 120%;
  height: 14px;
  position: absolute;
  top: -4px;
  left: -10px;
}

#inputr {
  z-index: 9;
  color: red;
  pointer-events: none;
  background: #0009;
  padding: 6px 10px;
  font-size: 9px;
  position: absolute;
  top: 200px;
}

#fps {
  z-index: 9;
  color: #add8e6;
  background: #0009;
  padding: 6px 10px;
  font-size: 9px;
  position: absolute;
  top: 200px;
  left: 200px;
}
</style>
    <img src="sky.jpg" style="display:none" id="skytexture">
    <img src="purplestone.jpg" style="display:none" id="walltexture">
</head>
<body>
    <p id="overlayText"><u>3D raycasting engine!!!!</u><br>You have to press once more to enable input.<br>Use WASD and arrows to move and look around.
        <br><span style="color:yellow;">click on this to remove the text</span></p>
    
	<img src="preview.png" id="preview">
    <canvas id="canvas1" width="250" height="250"></canvas>
    <canvas id="canvas2" width="250" height="250"></canvas>
    <input id="textfield" autocomplete="off"><br>
    <div id="border-top"></div>
    
    <p id="inputr">
        not receiving input
    </p>
    
	<p id="fps">
        FPS: 0
    </p>
    <script type="text/tilescript">// =====================
// globals
// =====================
var frames = 0;
var fps = 0;
var maxRays = 16;
var lastFpsTime = Date.now();

var W = 250;
var H = 250;

var DEG = 360;

var sinLUT = new Array(DEG);
var cosLUT = new Array(DEG);
var invSinLUT = new Array(DEG);
var invCosLUT = new Array(DEG);

function abs(x) { return x < 0 ? -x : x; }

// normalize any integer angle to [0..359]
function normAng(a) {
  a = a | 0;
  a %= 360;
  return a < 0 ? a + 360 : a;
}

function precomputeTrig() {
  for (var i = 0; i < DEG; i++) {
    var rad = i * Math.PI / 180;
    var s = Math.sin(rad);
    var c = Math.cos(rad);

    sinLUT[i] = s;
    cosLUT[i] = c;

    invSinLUT[i] = abs(s) < 1e-6 ? (s < 0 ? -1e6 : 1e6) : 1 / s;
    invCosLUT[i] = abs(c) < 1e-6 ? (c < 0 ? -1e6 : 1e6) : 1 / c;
  }
}

// =====================
// canvases + contexts 
// =====================
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');

canvas.width = W;
canvas.height = H;

var back = document.createElement('canvas');
back.width = W;
back.height = H;
var bctx = back.getContext('2d');

var preview = document.getElementById('preview');
preview.style.display = 'none';

// =====================
// sky pattern 
// =====================
var skyPattern = null;
var skyImg = document.getElementById("skytexture");
skyPattern = ctx.createPattern(skyImg, "repeat");

// =====================
// simple procedural wall texture
// =====================
function makeBrickTexture(w, h, color1, color2) {
  var c = document.createElement('canvas');
  c.width = w; c.height = h;
  var g = c.getContext('2d');

  var brickW = 16, brickH = 8, mortar = 1;

  g.fillStyle = color1;
  g.fillRect(0, 0, w, h);

  g.fillStyle = color2;
  for (var y = 0; y < h; y += brickH) {
    var offset = (((y / brickH) | 0) & 1) ? (brickW >> 1) : 0;
    for (var x = -offset; x < w; x += brickW) {
      g.fillRect(x + mortar, y + mortar, brickW - 2 * mortar, brickH - 2 * mortar);
    }
  }
  return c;
}

var redBrick = makeBrickTexture(16, 24, "darkred", "rgb(25, 0, 0)");
var greenBrick = makeBrickTexture(16, 24, "darkgreen", "rgb(0, 25, 0)");
var blueBrick = makeBrickTexture(16, 24, "darkblue", "rgb(0, 0, 25)");
var yellowBrick = makeBrickTexture(16, 24, "darkyellow", "rgb(25, 25, 0)");
var purpleBrick = makeBrickTexture(16, 24, "darkpurple", "rgb(0, 25, 25)");
var whiteBrick = makeBrickTexture(16, 24, "gray", "rgb(25, 25, 25)");

// =====================
// overlay
// =====================
var overlay = document.getElementById('overlayText');
if (overlay) {
  overlay.onclick = function() { overlay.style.display = 'none'; };
}

// =====================
// world + player
// =====================
var emptyTile = '.';

function World(width, height, map) {
  this.width = width;
  this.height = height;
  this.map = map;

  this.tileX = W / width;
  this.tileY = H / height;
}

function Player(x, y, angle, speed, size, world) {
  this.x = x;
  this.y = y;

  this.angle = normAng(angle);

  this.speed = speed;
  this.size = size;

  this.sinA = 0;
  this.cosA = 1;

  this.FOV = 45;
  this.world = world;
}

Player.prototype.update = function() {
  this.angle = normAng(this.angle);

  this.sinA = sinLUT[this.angle];
  this.cosA = cosLUT[this.angle]

  if (keys[0]) { // W
    this.x += this.speed * this.cosA;
    this.y += this.speed * this.sinA;
  }
  if (keys[2]) { // S
    this.x -= this.speed * this.cosA;
    this.y -= this.speed * this.sinA;
  }
  if (keys[1]) { // A 
    this.x += this.speed * this.sinA;
    this.y -= this.speed * this.cosA;
  }
  if (keys[3]) { // D
    this.x -= this.speed * this.sinA;
    this.y += this.speed * this.cosA;
  }

  if (keys[4]) this.angle = normAng(this.angle - 10);
  if (keys[5]) this.angle = normAng(this.angle + 10);
};

Player.prototype.castRay = function(aDeg) {
  aDeg = normAng(aDeg);

  var sin = sinLUT[aDeg];
  var cos = cosLUT[aDeg];

  var invCos = invCosLUT[aDeg];
  var invSin = invSinLUT[aDeg];

  var px = this.x / this.world.tileX;
  var py = this.y / this.world.tileY;

  var mx = px | 0;
  var my = py | 0;

  var dx = abs(invCos);
  var dy = abs(invSin);

  var sx = (cos < 0) ? -1 : 1;
  var sy = (sin < 0) ? -1 : 1;

  var rx = ((sx < 0) ? (px - mx) : (mx + 1 - px)) * dx;
  var ry = ((sy < 0) ? (py - my) : (my + 1 - py)) * dy;

  var side = 0;
  var tile = emptyTile;

  var steps = 0;
  var maxSteps = this.world.width * this.world.height + 64;

  var maxDistTiles = 15;

  while (steps++ < maxSteps) {
    if (rx < ry) { rx += dx; mx += sx; side = 0; }
    else         { ry += dy; my += sy; side = 1; }
    var traveled = (side === 0) ? (rx - dx) : (ry - dy);
    if (traveled > maxDistTiles) {
      return { dist: 200, texX: 10, side: side, tile: 'x' };
    }
    if (mx < 0 || my < 0 || mx >= this.world.width || my >= this.world.height) {
      tile = emptyTile;
      continue;
    }
    tile = this.world.map[my][mx];
    if (tile !== emptyTile) break;
  }
    
  var distTiles = (side === 0)
    ? (mx - px + (1 - sx) / 2) * invCos
    : (my - py + (1 - sy) / 2) * invSin;

  var dist = distTiles * this.world.tileX;

  var hit = (side === 0) ? (py + distTiles * sin) : (px + distTiles * cos);
  hit -= Math.floor(hit);

  return { dist: dist, texX: hit, side: side, tile: tile };
};

// =====================
// input
// =====================
var textfield = document.getElementById('textfield');
var inputr = document.getElementById('inputr');

function focusInput() { if (textfield) textfield.focus(); }
canvas.onclick = focusInput;

if (textfield && inputr) {
  textfield.addEventListener('focus', function() {
    inputr.innerText = 'receiving input';
    inputr.style.color = 'green';
  });
  textfield.addEventListener('blur', function() {
    inputr.innerText = 'not receiving input';
    inputr.style.color = 'red';
  });
}

var keys = [false, false, false, false, false, false];
var controls = ['w', 'a', 's', 'd', 'ArrowLeft', 'ArrowRight'];

function onKeyDown(e) {
  for (var i = 0; i < 6; i++) if (e.key === controls[i]) keys[i] = true;
}
function onKeyUp(e) {
  for (var i = 0; i < 6; i++) if (e.key === controls[i]) keys[i] = false;
}

if (textfield) {
  textfield.addEventListener('keydown', onKeyDown, true);
  textfield.addEventListener('keyup', onKeyUp, true);
}

// =====================
// map + init
// =====================
var map1 = [
  '##########',
  '#........#',
  '#.pr..gp.#',
  '#.b....r.#',
  '..........',
  '..........',
  '#.r....y.#',
  '#.gp..rg.#',
  '#........#',
  '##########'
];

var world = new World(10, 10, map1);
var player = new Player(125, 125, 90, 5, 10, world);

var efps = document.getElementById('fps');

precomputeTrig();

// =====================
// rendering
// =====================

function drawFarGroundFog(ctx) {
  var HALF_H = (H >> 1);
  var fogR = 170, fogG = 190, fogB = 210;
  var g = ctx.createLinearGradient(0, H, 0, HALF_H);

  g.addColorStop(0.00, "rgba(" + fogR + "," + fogG + "," + fogB + ",0.00)");
  g.addColorStop(0.35, "rgba(" + fogR + "," + fogG + "," + fogB + ",0.06)");
  g.addColorStop(0.70, "rgba(" + fogR + "," + fogG + "," + fogB + ",0.20)");
  g.addColorStop(1.00, "rgba(" + fogR + "," + fogG + "," + fogB + ",0.55)");

  ctx.fillStyle = g;
  ctx.fillRect(0, HALF_H, W, HALF_H);
}

function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }
function smooth01(t){ return t * t * (3 - 2 * t); }

ctx.globalAlpha = 1;
ctx.globalCompositeOperation = 'source-over';

function drawFrame(player, ctx) {
  var HALF_H = (H >> 1);

  if (skyPattern) {
    var shift = (player.angle / 360) * W * 2;
    ctx.save();
    ctx.translate(-shift, 0);
    ctx.fillStyle = skyPattern;
    ctx.fillRect(0, 0, W * 3, H);
    ctx.restore();
  } else {
    ctx.fillStyle = "#333";
    ctx.fillRect(0, 0, W, H);
  }
    
  var HALF_H = (H >> 1);
  ctx.fillStyle = "rgba(10, 40, 10, 0.18)";
  ctx.fillRect(0, HALF_H, W, HALF_H);
    
  drawFarGroundFog(ctx);

  var g = ctx.createLinearGradient(0, HALF_H, 0, H);
  g.addColorStop(0.0, "rgba(0,0,0,0.15)");
  g.addColorStop(0.6, "rgba(0,0,0,0.35)");
  g.addColorStop(1.0, "rgba(0,0,0,0.50)");
  ctx.fillStyle = g;
  ctx.fillRect(0, HALF_H, W, HALF_H);

  var RAYS = maxRays;
  var FOV = player.FOV;     // degrees
  var WALL_H = 30;

  var step = FOV / RAYS;
  var base = player.angle - (FOV * 0.5) + (step * 0.5);
    
  var fogStart = 2 * player.world.tileX;                  // start fog after 2 tiles
  var fogEnd   = 15* player.world.tileX;  // fully fog at render distance
  var fogR = 120, fogG = 140, fogB = 160;                 // fog color (match sky vibe)

  for (var i = 0; i < RAYS; i++) {
    var rayAng = base + i * step;
    var r = player.castRay(rayAng);

    if (!r || !r.tile || r.dist >= 1e6) continue;
      
	var img = null;
      
   	if (r.tile == "r") img = redBrick;
    if (r.tile == "g") img = greenBrick;
    if (r.tile == "b") img = blueBrick;
    if (r.tile == "y") img = yellowBrick;
    if (r.tile == "p") img = purpleBrick;
    if (r.tile == "#") img = whiteBrick;
      
    var fogR = 170, fogG = 190, fogB = 210;   // strong bright fog (tweak)
    var fogAlpha = 0.85;                      // strong

    if (r.tile === 'x') {
      var x0 = (i * W / RAYS) | 0;
      var x1 = ((i + 1) * W / RAYS) | 0;
      var w  = (x1 - x0) | 0;

      // ONLY sky area fog (no ground)
      // strongest near horizon, slightly weaker at very top
      var g = ctx.createLinearGradient(0, 0, 0, HALF_H);
      g.addColorStop(0.00, "rgba(" + fogR + "," + fogG + "," + fogB + "," + (fogAlpha * 0.55) + ")");
      g.addColorStop(1.00, "rgba(" + fogR + "," + fogG + "," + fogB + "," + fogAlpha + ")");
      ctx.fillStyle = g;
      ctx.fillRect(x0, 0, w, HALF_H);

      continue;
    }
      
    var imgW = img.width;
    var imgH = img.height;

    var corrAng = normAng((rayAng | 0) - player.angle);
    var d = r.dist * cosLUT[corrAng];
    if (d < 0.0001) d = 0.0001;

    var h = (WALL_H * H / d) | 0;

    var x0 = (i * W / RAYS) | 0;
    var x1 = ((i + 1) * W / RAYS) | 0;
    var w = (x1 - x0) | 0;

    var u = r.texX;
    if (u < 0) u = 0;
    else if (u > 0.9999) u = 0.9999;

    var texX = (u * imgW) | 0;
    var y0 = (HALF_H - (h >> 1)) | 0;

    ctx.drawImage(
      img,
      texX, 0, 1, imgH,
      x0, y0, w, h
    );

    var t = clamp01((r.dist - fogStart) / (fogEnd - fogStart));
    t = smooth01(t);

    ctx.fillStyle = "rgba(" + fogR + "," + fogG + "," + fogB + "," + t + ")";
    ctx.fillRect(x0, y0, w, h);

    if (r.side === 1) {
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(x0, y0, w, h);
    }
  }
}

// =====================
// main loop
// =====================
function loop() {
  var now = Date.now();

  frames++;
  if (now - lastFpsTime >= 1000) {
    fps = frames;
    frames = 0;
    lastFpsTime = now;
    if (efps) efps.innerText = "FPS: " + fps;
  }

  drawFrame(player, bctx);
    
  ctx.drawImage(back, 0, 0)

  player.update();

  setTimeout(loop, 50);
}

loop();</script>
</body>
</html>	