<!DOCTYPE html>
<html lang="en">
<head>
    <style>.tile-body {
  color: #00bfff;
  background-color: #000;
  background-image: url("tiletemp.gif");
  justify-content: center;
  align-items: center;
  font-family: MS UI Gothic, MS PGothic, sans-serif;
  display: flex;
}

a {
  color: #ff0;
}

p {
  text-align: center;
}

canvas {
  position: absolute;
  bottom: 5px;
  left: 5px;
}

#star {
  position: absolute;
  top: 5px;
  left: 5px;
}

#button {
  position: absolute;
  top: 5px;
  right: 5px;
}

#icon {
  position: absolute;
  top: 50px;
}

#play {
  position: absolute;
  bottom: 5px;
  left: 5px;
}

#flash {
  position: absolute;
  bottom: 5px;
  right: 5px;
}

#click {
  position: absolute;
  bottom: 85px;
}

#discord {
  position: absolute;
  bottom: 62px;
}
</style>
</head>
<body>
    <a id="icon" href="https://starcade.nekoweb.org" target="_blank"><img src="starcade_icon_transparent.png" width="240"></a>
    
    <div>
    	<img id="star" src="starsc.png" style="width:69px;height:52px;">
   	 	
        <img id="button" src="starcadebutton.gif">
        <img id="play" src="playmygames.gif" width="96">
        <img id="flash" src="FLASH8.png" width="64">
    </div>
    <div id="click">
        <p>
            <a href="https://starcade.nekoweb.org/sdd2" target="_blank">SDD2 v1.1: Yarnition bug fixed!</a>
        </p>
    </div>
    <div id="discord">
        <p>
            <a href="https://discord.gg/w4xz4phFUW" target="_blank">Talk to me in my Discord Server!</a>
        </p>
    </div>
    <script type="text/tilescript">restart();
var xmouse = 0;
var ymouse = 0;

var canvas = document.getElementById("sddcanvas");
var ctx = canvas.getContext("2d");
var canvas2 = document.getElementById("sddcanvas2");
var ctx2 = canvas2.getContext("2d");
var activecanvas = canvas;
var activectx = ctx;
var sprite_sheet = document.createElement("img");
sprite_sheet.src = "spritesheet.png";
var game_ui = document.createElement("img");
game_ui.src = "ui.png";
var map1 = document.createElement("img");
map1.src = "courtyard.png";
var map2 = document.createElement("img");
map2.src = "snowy.png";
var map3 = document.createElement("img");
map3.src = "palace.png";
var maps = [map1, map2, map3];
var mapNames = ["courtyard", "snow field", "palace"];
var mapRecords = [0, 0, 0];
var mapRecordNames = ["", "", ""];
var selectedUpgradeCost = -1;
var selectedDamage = -1;
var selectedRange = -1;
var selectedSpeed = -1;
var tempDamage = -1;
var tempRange = -1;
var tempSpeed = -1;

var gamespeed = 50;
var dotTimer = 0;

var touchtext = "";

var sprite_size = 9;

var sprites = {
	blank: [0, 2],
	c_a: [0, 0],
	c_b: [1, 0],
	c_c: [2, 0],
	c_d: [3, 0],
	c_e: [4, 0],
	c_f: [5, 0],
	c_g: [6, 0],
	c_h: [7, 0],
	c_i: [8, 0],
	c_j: [9, 0],
	c_k: [10, 0],
	c_l: [11, 0],
	c_m: [12, 0],
	c_n: [13, 0],
	c_o: [14, 0],
	c_p: [15, 0],
	c_q: [16, 0],
	c_r: [17, 0],
	c_s: [18, 0],
	c_t: [0, 1],
	c_u: [1, 1],
	c_v: [2, 1],
	c_w: [3, 1],
	c_x: [4, 1],
	c_y: [5, 1],
	c_z: [6, 1],
	c_0: [7, 1],
	c_1: [8, 1],
	c_2: [9, 1],
	c_3: [10, 1],
	c_4: [11, 1],
	c_5: [12, 1],
	c_6: [13, 1],
	c_7: [14, 1],
	c_8: [15, 1],
	c_9: [16, 1],
	c_period: [17, 1],
	c_minus: [18, 1],
	c_plus: [18, 2],
	c_exclamation: [18, 3]
};

function restart() {
	gamescreen = "game";
	map = 2;
	money = 25;
	lives = 50;
	round = 0;
	towerNames = ["red regular", "blue bomber", "violet splasher", "amber tapper"];
	towerCost = [10, 25, 70, 95];
	towerDamage = [1, 2, 3, 5];
	towerRange = [4, 3, 2, 999];
	towerSpeed = [20, 30, 40, 24];
	towerTile = [[2, 4], [2, 6], [0, 8], [2, 8]];
	upgradeNames = ["heart monitor", "slime bombs", "fire flower", "auto clicker"];
	upgradeCost = [85, 100, 135, 250];
	upgradeDamage = [3, 4, 5, 9];
	upgradeRange = [6, 4, 3, 999];
	upgradeSpeed = [18, 25, 30, 10];
	
	towerData = []; // type, x, y, upgrade level, sell value, direction, cooldown
	
	path = [ // x, y, next direction: 0 right 1 down 2 left 3 up 4 finish
	[[1, 7, 0], [8, 7, 3], [8, 3, 0], [20, 3, 1], [20, 13, 2], [4, 13, 3], [4, 9, 0], [16, 9, 1], [16, 16, 4]],
	[[1, 14, 0], [5, 14, 3], [5, 11, 0], [11, 11, 1], [11, 12, 0], [17, 12, 3], [17, 3, 2], [15, 3, 1], [15, 5, 0], [22, 5, 3], [22, 2, 0], [24, 2, 4]],
	[[13, 0, 1], [13, 3, 2], [8, 3, 1], [8, 13, 0], [13, 13, 1], [13, 16, 4]],
	[[13, 16, 3], [13, 13, 0], [18, 13, 3], [18, 3, 2], [13, 3, 3], [13, 0, 4]]
	]; 
	
	canPlace = [ // sorry for the huge array
	[[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, true, true, true],
	[true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true],
	[true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true],
	[true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true],
	[true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true]],
	
	[[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, false, true, true, true, true, false, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, false, true, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true],
	[true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true]],
	
	[[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true]]
	];
	hoveringTower = -1;
	buyingTower = -1;
	selectedTower = -1;
	
	dotData = []; // hp, x, y, current speed mult, distance traveled, direction, path, target
	
	effectData = []; // type, x, y, lifespan
	
	autoStart = false;
	roundStarted = false;
	roundEnded = true;
	roundSpawns = [];
	roundData = [ // dot hp, amount, delay
	// standard: 1-10 hp
	// spider: 11-20 hp
	// flower: 21-30 hp
	// shell: 31-40 hp
	// gold: 41-50 hp
	// ruby: 51-100 hp
	// emerald: 101-200 hp
	// sapphire: 201-300 hp
	// amethyst: 301-400 hp
	// aquamarine: 401+ hp
	[[1, 12, 16], [1, 8, 8]], // 1
	[[1, 25, 4]], // 2
	[[1, 5, 5], [2, 10, 10], [1, 5, 5]], // 3
	[[3, 9, 6]], // 4
	[[5, 5, 5], [4, 8, 8], [3, 12, 12], [2, 16, 6], [1, 20, 1]], // 5
	[[1, 24, 4], [10, 1, 10]], // 6
	[[4, 10, 5], [5, 7, 10], [6, 4, 15]], // 7
	[[2, 25, 2], [3, 20, 3], [4, 15, 4]], // 8
	[[5, 10, 15], [6, 10, 5]], // 9
	[[20, 1, 20]], // 10
	[[7, 5, 10], [4, 20, 9], [5, 15, 8], [6, 10, 7]], // 11
	[[4, 18, 10], [6, 15, 11], [8, 12, 12]], // 12
	[[20, 1, 20], [9, 18, 9], [20, 1, 20]], // 13
	[[9, 15, 15], [6, 25, 2.5]], // 14
	[[20, 3, 18], [30, 1, 22]], // 15
	[[4, 24, 4], [30, 2, 20], [4, 24, 4]], // 16
	[[7, 45, 3], [20, 5, 17]], // 17
	[[10, 16, 7], [9, 16, 6], [8, 16, 5]], // 18
	[[5, 20, 5], [10, 15, 7.5], [20, 10, 10]], // 19
	[[40, 1, 40], [10, 9, 9]], // 20
	[[9, 27, 9], [30, 3, 15]], // 21
	[[10, 25, 2.5]], // 22
	[[30, 3, 10], [40, 4, 10]], // 23
	[[50, 1, 20], [5, 8, 2], [50, 1, 20]], // 24
	[[3, 28, 4], [5, 14, 5], [7, 13, 6], [9, 12, 7], [20, 11, 8]], // 25
	[[10, 9, 4], [40, 2, 20], [20, 9, 4]], // 26
	[[1, 75, 1], [4, 15, 2], [10, 10, 3], [40, 5, 4]], // 27
	[[50, 3, 7]], // 28
	[[30, 5, 6], [40, 5, 4]], // 29
	[[5, 11, 5], [20, 8, 5], [50, 5, 5]], // 30
	[[20, 5, 6], [30, 7, 6], [40, 7, 8]], // 31
	[[50, 1, 6], [40, 6, 5], [20, 8, 4]], // 32
	[[30, 20, 5]], // 33
	[[10, 45, 1], [40, 5, 2]], // 34
	[[30, 5, 6], [20, 20, 4], [10, 35, 2]], // 35
	[[9, 49, 3], [8, 51, 2]], // 36
	[[10, 9, 6], [20, 8, 6], [30, 8, 4], [40, 9, 4]], // 37
	[[5, 37, 1], [7, 35, 1], [50, 12, 8], [9, 17, 2]], // 38
	[[20, 12, 4], [10, 11, 4], [50, 6, 4], [40, 11, 8], [30, 12, 8]], // 39
	[[50, 13, 5], [100, 2, 50]], // 40
	[[40, 16, 5], [30, 16, 5]], // 41
	[[30, 30, 3], [50, 20, 5]], // 42
	[[100, 1, 25], [40, 20, 5], [20, 20, 5], [100, 2, 25]], // 43
	[[10, 25, 1], [100, 1, 10], [20, 24, 2]], // 44
	[[200, 4, 80]], // 45
	[[5, 10, 15], [6, 10, 5]], // 46
	[[5, 10, 15], [6, 10, 5]], // 47
	[[5, 10, 15], [6, 10, 5]], // 48
	[[5, 10, 15], [6, 10, 5]], // 49
	[[200, 1, 50]], // 50
	[[5, 10, 15], [6, 10, 5]], // 51
	[[5, 10, 15], [6, 10, 5]], // 52
	[[5, 10, 15], [6, 10, 5]], // 53
	[[5, 10, 15], [6, 10, 5]], // 54
	[[5, 10, 15], [300, 1, 50]], // 55
	[[5, 10, 15], [6, 10, 5]], // 56
	[[5, 10, 15], [6, 10, 5]], // 57
	[[5, 10, 15], [6, 10, 5]], // 58
	[[5, 10, 15], [6, 10, 5]], // 59
	[[400, 5, 10]], // 60
	[[5, 10, 15], [6, 10, 5]], // 61
	[[5, 10, 15], [6, 10, 5]], // 62
	[[100, 16, 4], [50, 32, 0], [100, 16, 4], [50, 32, 0], [100, 16, 4], [50, 32, 0]], // 63
	[[5, 10, 15], [6, 10, 5]], // 64
	[[5, 10, 15], [6, 10, 5]], // 65
	[[5, 10, 15], [6, 10, 5]], // 66
	[[5, 10, 15], [6, 10, 5]], // 67
	[[5, 10, 15], [6, 10, 5]], // 68
	[[5, 10, 15], [6, 10, 5]], // 69
	[[10000, 1, 100]], // 70
	];
	totalDots = 0;
	//var grid = 
}

restart();
var fram = 0;
var last = 0;
var drawing = false;
var draw_x = 3;
var draw_y = 2;

// GAMEPLAY STUFF
function startRound() {
	dotTimer = 1;
	roundSpawns = [];
	if (roundData.length <= round) {
		roundSpawns.push([[30, 10, 2]]);
	}
	else {
		roundSpawns.push(roundData[round]);
	}
	roundStarted = true;
	roundEnded = false;
	totalDots = 0;
	round++;
}

function towerSprite(_tower, _lvl, _d) {
	switch (_tower) {
		case 0:
		return [_d, 4+(_lvl >= 2)];
		break;
		case 1:
		return [_d, 6+(_lvl >= 2)];
		break;
		case 2:
		return [0, 8+(_lvl >= 2)];
		break;
		case 3:
		return [1+Math.floor(_d/2), 8+(_lvl >= 2)];
		break;
		default:
		break;
	}
}

function getTowerStats(_type, _lvl) {
	if (_lvl >= 2) {
		selectedDamage = upgradeDamage[_type];
		selectedRange = upgradeRange[_type];
		selectedSpeed = upgradeSpeed[_type];
	}
	else {
		selectedDamage = towerDamage[_type] + ((_type == 3) + 1) * _lvl;
		selectedRange = towerRange[_type] + _lvl;
		selectedSpeed = towerSpeed[_type];
	}
}

function getTowerStats2(_type, _lvl) {
	if (_lvl >= 2) {
		tempDamage = upgradeDamage[_type];
		tempRange = upgradeRange[_type];
		tempSpeed = upgradeSpeed[_type];
	}
	else {
		tempDamage = towerDamage[_type] + ((_type == 3) + 1) * _lvl;
		tempRange = towerRange[_type] + _lvl;
		tempSpeed = towerSpeed[_type];
	}
}

function dotSprite(_hp, _d) {
	if (_hp > 400) return [15, 8+_d]; // AQUAMARINE
	else if (_hp > 50) return [Math.ceil(_hp / 100 + 10), 8+_d]; // RUBY, EMERALD, SAPPHIRE, AMETHYST
	else if (_hp > 20) return [Math.ceil(_hp / 10 + 5), 8+_d]; // FLOWER, SHELL, GOLD
	else if (_hp > 10) return [18, 4+_d]; // SPIDER
	else if (_hp > 0) return [Math.ceil(_hp + 7), 4+_d]; // STANDARD
	else return [18, 11]; // NONE
}

function moveDots() {
	for (i = 0; i < dotData.length; i++) {
		dotSpeed = (dotData[i][0] >= 21) ? 5 / dotData[i][0] : dotData[i][0] / 100 + 0.1;
		dotData[i][4] += dotSpeed * dotData[i][3];
		switch (dotData[i][5]) {
			case 0: // right
			dotData[i][1] += dotSpeed * dotData[i][3];
			break;
			case 1: // down
			dotData[i][2] += dotSpeed * dotData[i][3];
			break;
			case 2: // left
			dotData[i][1] -= dotSpeed * dotData[i][3];
			break;
			case 3: // up
			dotData[i][2] -= dotSpeed * dotData[i][3];
			break;
		}
		if (Math.abs(dotData[i][1] - path[dotData[i][6]][dotData[i][7]][0]) <= dotSpeed * 1.1 && Math.abs(dotData[i][2] - path[dotData[i][6]][dotData[i][7]][1]) <= dotSpeed * 1.1) {
			dotData[i][1] = path[dotData[i][6]][dotData[i][7]][0];
			dotData[i][2] = path[dotData[i][6]][dotData[i][7]][1];
			dotData[i][7] += 1;
			dotData[i][5] = path[dotData[i][6]][dotData[i][7]-1][2];
		}
		if (dotData[i][0] >= 51 && dotData[i][0] <= 99) dotData[i][0] += 0.1; // RUBY
		else if (dotData[i][0] >= 101 && dotData[i][0] <= 200) dotData[i][0] += 0.1; // EMERALD
		if (dotData[i][5] == 4) {
				lives -= dotData[i][0];
				dotData.splice(i, 1);
		}
		else if (dotData[i][0] <= 0) dotData.splice(i, 1);
	}
}

function checkImmunities(_tower, _level, _hp) {
	if (_hp > 400) return (_tower != 1 && _tower != 2); // AQUAMARINE
	else if (_hp > 40 && _hp <= 50) return (_tower != 0 && (_tower != 2 || _level >= 2)); // GOLD
	else if (_hp > 30 && _hp <= 40) return (_tower != 1); // SHELL
	else if (_hp > 20 && _hp <= 30) return (_tower != 2); // FLOWER
	else return true;
}

function damageDot(_id, _amount) {
	if (dotData[_id][0] >= _amount) {
		money += dotData[_id][0] / Math.pow(round, 1.5);
	}
	else {
		money += _amount / Math.pow(round, 1.5);
	}
	dotData[_id][0] -= _amount;
	
	//if (dotData[_id][0] <= 0) {
		//dotData.splice(_id, 1);
	//}
}

function damageRadius(_x, _y, _amount, _range, _slime) {
	for (j = 0; j < dotData.length; j++) {
		if (distanceFrom(_x, _y, dotData[j][1], dotData[j][2]) <= _range && (checkImmunities(1, 0, dotData[j][0]))) {
			damageDot(j, _amount);
			if (_slime) {
				dotData[j][3] = 0.5;
			}
		}
	}
}

function distanceFrom(_x, _y, _x2, _y2) {
	return Math.sqrt(Math.pow(_x2 - _x, 2)+Math.pow(_y2 - _y, 2));
}

function pointTowards(_x, _y, _x2, _y2) {
	return Math.atan2(_x2 - _x, _y2 - _y)*180/Math.PI;
}

// MOUSE DETECTION

function canvas_move(_event) {
	xmouse = get_mouse_pos(activecanvas, _event, true).x;
	ymouse = get_mouse_pos(activecanvas, _event, true).y;
	switch (gamescreen) {
		case "mapselect":
		
		
		break;
		case "help":
		
		break;
		case "game":
			touchtext = "";
			if (buyingTower >= 0) {
				touchtext = towerNames[buyingTower];
			}
			else if (selectedTower >= 0) {
				touchtext = towerNames[towerData[selectedTower][0]];
			}
			hoveringTower = -1;
			for (i = 0; i < 4; i++) {
				if (touching(0, i*3+4, 1, i*3+5)) {
					touchtext = towerNames[i];
					hoveringTower = i;
				}
			}
			
		break;
	}
	
	//if (drawing) tile([draw_x, draw_y], xmouse, ymouse);
	
}


function canvas_click(_event) {
	console.log(get_mouse_pos(activecanvas, _event, true));
	//drawing = !drawing;
	
	switch (gamescreen) {
		case "mapselect":
		
		break;
		case "help":
		
		break;
		case "game":
		
		// START ROUND
		if (touching(22, 16, 23, 16)) {
			if (!roundStarted && roundEnded) startRound(); else autoStart = !autoStart;
		}
		
		if (buyingTower >= 0 && (xmouse >= 2 && xmouse <= 23 && ymouse >= 1 && ymouse <= 15) && canPlace[map][ymouse-1][xmouse-2] && money >= towerCost[buyingTower]) {
			towerData.push([buyingTower, xmouse, ymouse, 0, Math.floor(towerCost[buyingTower] * 0.75), 2, 0]);
			money -= towerCost[buyingTower];
			canPlace[map][ymouse-1][xmouse-2] = false;
			buyingTower = -1;
		}
		for (i = 0; i < 4; i++) {
		  if (touching(0, i*3+4, 1, i*3+5) && money >= towerCost[i]) buyingTower = i;
		}
		if (touching(0, 15, 1, 15)) { 
			buyingTower = -1;
		}
		if (ymouse <= 15) {
			selectedTower = -1;
		}
		else if (selectedTower >= 0) {
			if (touching(5, 16, 8, 17) && towerData[selectedTower][3] <= 1 && selectedUpgradeCost >= 0 && money >= selectedUpgradeCost) {
				money -= selectedUpgradeCost;
				towerData[selectedTower][4] += selectedUpgradeCost * 0.75;
				towerData[selectedTower][3]++;
			}
			else if (touching(17, 17, 20, 17)) {
				money += towerData[selectedTower][4];
				canPlace[map][towerData[selectedTower][2]-1][towerData[selectedTower][1]-2] = true;
				towerData.splice(selectedTower, 1);
				selectedTower = -1;
			}
		}
		if (touching(22, 17, 23, 17)) gamespeed = 70 - gamespeed;
		for (i = 0; i < towerData.length; i++) {
			if (touching(towerData[i][1], towerData[i][2], towerData[i][1], towerData[i][2]) && buyingTower == -1) {
				selectedTower = i;
				touchtext = touchtext = towerNames[towerData[selectedTower][0]];
			}
		}
		break;
	}
}

function get_digit(_dig) {
	switch (_dig) {
		case " ":
		return "blank";
		break;
		case ".":
		return "c_period";
		break;
		case "-":
		return "c_minus";
		break;
		case "+":
		return "c_plus";
		break;
		case "!":
		return "c_exclamation";
		break;
		default:
		return "c_"+_dig;
		break;
	}
}

function print(_text, _x, _y) {
	for (i = 0; i < _text.length; i++) {
		tile(sprites[get_digit(_text.charAt(i))], _x+i, _y);
	}
}

function get_mouse_pos(_canvas, _event, _grid) {
    var rect = _canvas.getBoundingClientRect();
    var scale_x = _canvas.width / rect.width;
    var scale_y = _canvas.height / rect.height;

    var pos = {
        x: (_event.clientX - rect.left) * scale_x,
		y: (_event.clientY - rect.top) * scale_y
    };
    
    if (!_grid) {
        return pos;
    }
    
    pos.x = Math.floor(pos.x/sprite_size);
    pos.y = Math.floor(pos.y/sprite_size);
	
    return pos;
}

function touching(_x1, _y1, _x2, _y2) {
	return ((xmouse >= _x1 && ymouse >= _y1) && (xmouse <= _x2 && ymouse <= _y2));
}

function tile(_tile, _x, _y) {
	activectx.drawImage(
        sprite_sheet,
        _tile[0]*sprite_size,
        _tile[1]*sprite_size,
        sprite_size,
        sprite_size,
        sprite_size*_x,
        sprite_size*_y,
        sprite_size,
        sprite_size
    );
}

canvas.addEventListener("mousemove", canvas_move, false);
canvas.addEventListener("click", canvas_click, false);
canvas2.addEventListener("mousemove", canvas_move, false);
canvas2.addEventListener("click", canvas_click, false);

function renderCanvas(_canvas, _ctx, _canvas2) {
	doneRendering = false;
	activecanvas = _canvas;
	activectx = _ctx;
	switch (gamescreen) {
		case "mapselect":
		
		
		break;
		case "help":
		
		break;
		case "game":
		
		_ctx.drawImage(maps[map], 0, 0);
		
		// DRAW TOWERS
		for (i = 0; i < towerData.length; i++) {
			tile(towerSprite(towerData[i][0], towerData[i][3], towerData[i][5]), towerData[i][1], towerData[i][2]);
		}
		
		// DRAW DOTS
		for (i = 0; i < dotData.length; i++) {
			tile(dotSprite(dotData[i][0], dotData[i][5]), dotData[i][1], dotData[i][2]);
		}
		
		_ctx.drawImage(game_ui, 0, 0);
		print(touchtext, 0, 0);
		if (lives <= 0) {
			lives = 0;
			print("game over! ping me", 6, 16);
			print("on discord your score", 4, 17);
			tile([15, 3], 23, 15);
			tile([16, 3], 24, 15);
		}
		print(Math.floor(money).toString(), 1, 16);
		print(Math.floor(lives).toString(), 1, 17);
		print("round "+round, 19-round.toString().length, 0);
		if (selectedTower >= 0 || buyingTower >= 0) {
			tile([13, 3], 0, 15);
			tile([14, 3], 1, 15);
			if (buyingTower >= 0) {
				tile(towerTile[buyingTower], xmouse, ymouse);
				_ctx.beginPath();
				_ctx.arc((xmouse + 0.5) * sprite_size, (ymouse + 0.5) * sprite_size, towerRange[buyingTower] * sprite_size, 0, 2 * Math.PI);
				_ctx.stroke();
			}
			
		}
		if (selectedTower >= 0) {
			// UPGRADE MENU
			getTowerStats(towerData[selectedTower][0], towerData[selectedTower][3]);
			tile([5, 3], 0, 1);
			tile([6, 3], 0, 2);
			tile([selectedDamage + 7, 1], 1, 1);
			tile((selectedRange >= 999) ? [7, 2] : [selectedRange + 7, 1], 1, 2);
			_ctx.beginPath();
			_ctx.arc((towerData[selectedTower][1] + 0.5) * sprite_size, (towerData[selectedTower][2] + 0.5) * sprite_size, selectedRange * sprite_size, 0, 2 * Math.PI);
			_ctx.stroke();
			switch (towerData[selectedTower][3]) {
				case 0:
				selectedUpgradeCost = Math.floor(towerCost[towerData[selectedTower][0]] / 1.78 + 12.5);
				tile([14, 2], 6, 17);
				print("base upgrade", 6, 16);
				print(selectedUpgradeCost.toString(), 7, 17);
				break;
				case 1:
				selectedUpgradeCost = upgradeCost[towerData[selectedTower][0]];
				tile([towerData[selectedTower][0]+7, 3], 6, 17);
				print(upgradeNames[towerData[selectedTower][0]], 6, 16);
				print(selectedUpgradeCost.toString(), 7, 17);
				break;
				default:
				selectedUpgradeCost = -1;
				break;
			}
			tile([11, 3], 17, 17);
			tile([12, 3], 18, 17);
			print(Math.floor(towerData[selectedTower][4]).toString(), 19, 17);
		}
		if (hoveringTower >= 0) {
			tile([5, 3], 0, 1);
			tile([6, 3], 0, 2);
			tile([towerDamage[hoveringTower] + 7, 1], 1, 1);
			tile((hoveringTower == 3) ? [7, 2] : [towerRange[hoveringTower] + 7, 1], 1, 2);
		}
		if (lives > 0) {
			tile([2 - (gamespeed <= 20) * 2, 11], 22, 17);
			tile([3 - (gamespeed <= 20) * 2, 11], 23, 17);
			if (autoStart) {
				tile([8, 2], 22, 16);
				tile([9, 2], 23, 16);
			}
			else if (!roundStarted && roundEnded) {
				tile([12, 2], 22, 16);
				tile([13, 2], 23, 16);
			}
			else {
				tile([10, 2], 22, 16);
				tile([11, 2], 23, 16);
			}
		}
		break;
	}
	doneRendering = true;
	_canvas.hidden = false;
	_canvas2.hidden = true;
}

var doneRendering = false;

function loop() {
	//ctx.clearRect(18, 9, canvas.width - 27, canvas.height - 27);
	
	// GAMEPLAY LOOP
	if (lives > 0) {
		
		// TOWER FUNCTIONALITY
		if (!roundEnded) {
			for (i = 0; i < towerData.length; i++) {
				towerData[i][6]--;
				if (towerData[i][6] <= 0) {
					// SEARCH FOR TARGET AND ATTACK
					getTowerStats2(towerData[i][0], towerData[i][3]);
					towerAttacked = false;
					towerCompare = -1;
					towerTarget = -1;
					if (towerData[i][0] == 2) { // VIOLET SPLASHER
						for (j = 0; j < dotData.length; j++) {
							if (distanceFrom(towerData[i][1], towerData[i][2], dotData[j][1], dotData[j][2]) <= tempRange) {
								if (checkImmunities(2, towerData[i][3], dotData[j][0])) {
									damageDot(j, tempDamage);
								}
							}
						}
					}
					else {
						for (j = 0; j < dotData.length; j++) {
							if (dotData[j][4] >= towerCompare && distanceFrom(towerData[i][1], towerData[i][2], dotData[j][1], dotData[j][2]) <= tempRange) {
								towerCompare = dotData[j][4];
								towerTarget = j;
							}
						}
						if (towerTarget >= 0 && !towerAttacked) {
							if (checkImmunities(towerData[i][0], towerData[i][3], dotData[towerTarget][0])) {
								if (dotData[towerTarget] != null) {
									towerData[i][5] = Math.round(10 - (pointTowards(towerData[i][1], towerData[i][2], dotData[towerTarget][1], dotData[towerTarget][2])/45)) % 8;
								}
								if (towerData[i][0] == 1) { // BLUE BOMBER
									damageRadius(dotData[towerTarget][1], dotData[towerTarget][2], tempDamage, 2, (towerData[i][3] >= 2));
								}
								else {
									if (towerData[i][0] == 0 && towerData[i][3] >= 2) { // HEART MONITOR
										money += 0.5;
										lives += 0.5;
									}
									damageDot(towerTarget, tempDamage);
								}
							}
						}
					}
					towerData[i][6] = (towerData[i][3] >= 2) ? upgradeSpeed[towerData[i][0]] : towerSpeed[towerData[i][0]];
				}
			}
		}
		
		
		// DOT SPAWNING
		if (roundStarted && roundSpawns[0].length >= 1) {
			if (dotTimer <= 0) {
				totalDots++;
				dotData.push([roundSpawns[0][0][0], path[map+(map == 2 && totalDots % 2 == 0)][0][0], path[map+(map == 2 && totalDots % 2 == 0)][0][1], 1, 0, path[map+(map == 2 && totalDots % 2 == 0)][0][2], map+(map == 2 && totalDots % 2 == 0), 1]);
				dotTimer = roundSpawns[0][0][2];
				roundSpawns[0][0][1]--;
				if (roundSpawns[0][0][1] <= 0) {
					roundSpawns[0].shift();
					if (roundSpawns[0].length <= 0) roundStarted = false;
				}
			}
			else {
				dotTimer--;
			}
		}
		else {
			if (!roundStarted && !roundEnded && dotData.length <= 0) {
				money += round;
				if (autoStart) {
					roundStarted = true;
					roundEnded = false;
					startRound(); 
				}
				else {
					roundEnded = true;
				}
			}
		}
		moveDots();
	}
	
	// FPS
	var now = Date.now();
	fram += 2;
	  if (now - last >= 500) {
		  //fps = 1000 / (now - last);
		fps = fram;
		fram = 0;
		  last = now;
		console.log(fps);
	  }
	
	// RENDERING
	if (fps >= 10) {
		renderCanvas(canvas, ctx, canvas2);
		renderCanvas(canvas2, ctx2, canvas);
	}
	setTimeout(loop, gamespeed);
}

loop();</script>
</body>
</html>