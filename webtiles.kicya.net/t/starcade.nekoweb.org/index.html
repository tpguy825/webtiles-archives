<!DOCTYPE html>
<html lang="en">
<head>
    <style>.tile-body {
  color: #00bfff;
  background-color: #000;
  background-image: url("tiletemp.gif");
  justify-content: center;
  align-items: center;
  font-family: MS UI Gothic, MS PGothic, sans-serif;
  display: flex;
}

a {
  color: #ff0;
}

p {
  text-align: center;
}

canvas {
  position: absolute;
  bottom: 5px;
  left: 5px;
}

#star {
  position: absolute;
  top: 5px;
  left: 5px;
}

#button {
  position: absolute;
  top: 5px;
  right: 5px;
}

#icon {
  position: absolute;
  top: 50px;
}

#play {
  position: absolute;
  bottom: 5px;
  left: 5px;
}

#flash {
  position: absolute;
  bottom: 5px;
  right: 5px;
}

#click {
  position: absolute;
  bottom: 85px;
}

#discord {
  position: absolute;
  bottom: 62px;
}

#click2 {
  width: 80px;
  position: absolute;
  top: 32px;
  left: 10px;
}

#discord2 {
  width: 90px;
  position: absolute;
  top: 32px;
  right: 10px;
}

#nlv {
  width: 85px;
  position: absolute;
  top: 32px;
  right: 91px;
}

#thumbnail {
  position: absolute;
  bottom: 5px;
  left: 5px;
}
</style>
</head>
<body>
    
    
    <div>
    	<img id="star" src="starsc.png" style="width:53px;height:39px;">
   	 	
        <img id="button" src="starcadebutton.gif">
        <img id="thumbnail" src="canvasdefault.png" width="225">
        <canvas id="sddcanvas2" class="game" width="225" height="162" style="border:1px solid #000000;">
			Your browser does not support the HTML canvas tag.
  		</canvas>
        <canvas id="sddcanvas" class="game" width="225" height="162" style="border:1px solid #000000;">
			Your browser does not support the HTML canvas tag.
  		</canvas>
        
    </div>
    <div id="nlv">
        <p>
            <a href="https://starcade.nekoweb.org/sdd2/tile" target="_blank">Non-Laggy Version</a>
        </p>
    </div>
    <div id="click2">
        <p>
            <a href="https://starcade.nekoweb.org/sdd2" target="_blank">Play the Flash Game!</a>
        </p>
    </div>
    <div id="discord2">
        <p>
            <a href="https://discord.gg/w4xz4phFUW" target="_blank">Join the Discord Server!</a>
        </p>
    </div>
    <script type="text/tilescript">restart();
var xmouse = 0;
var ymouse = 0;

var canvas = document.getElementById("sddcanvas");
var ctx = canvas.getContext("2d");
var canvas2 = document.getElementById("sddcanvas2");
var ctx2 = canvas2.getContext("2d");
var activecanvas = canvas;
var activectx = ctx;
var sprite_sheet = document.createElement("img");
sprite_sheet.src = "spritesheet.png";
var mapselectimage = document.createElement("img");
mapselectimage.src = "mapselect.png";
var helpimage = document.createElement("img");
helpimage.src = "help.png";
var game_ui = document.createElement("img");
game_ui.src = "ui.png";
var map1 = document.createElement("img");
map1.src = "courtyard.png";
var map2 = document.createElement("img");
map2.src = "snowy.png";
var map3 = document.createElement("img");
map3.src = "palace.png";
var maps = [map1, map2, map3];
var mapNames = ["courtyard", "snow field", "palace"];
var mapRecords = [0, 0, 0];
var mapRecordNames = ["   nobody", "   nobody", "   nobody"];
var selectedUpgradeCost = -1;
var selectedDamage = -1;
var selectedRange = -1;
var selectedSpeed = -1;
var tempDamage = -1;
var tempRange = -1;
var tempSpeed = -1;
var dotNames = ["standard", "spider", "flower", "shell", "gold", "ruby", "emerald", "sapphire", "amethyst", "diamond"];
var dotdesc = ["has no special features.", "moves really fast.", "cannot be damaged by", "cannot be damaged by", "metal property. immune", "regenerates 5 hp", "cannot be stunned", "takes half damage", "takes quarter damage", "takes one eighth damage."];
var dotdesc2 = [" ", " ", "violet splasher.", "blue bomber.", "to anything sharp.", "per second.", "or slowed down.", "from everything.", "from everything.", "immune to blue and violet"];
var dotHP = [10, 20, 30, 40, 50, 100, 200, 300, 400, 500];
var dotPage = 0;

var gamespeed = 50;
var dotTimer = 0;
var menuselect = -1;
var touchtext = "";

var sprite_size = 9;

var sprites = {
	blank: [0, 2],
	c_a: [0, 0],
	c_b: [1, 0],
	c_c: [2, 0],
	c_d: [3, 0],
	c_e: [4, 0],
	c_f: [5, 0],
	c_g: [6, 0],
	c_h: [7, 0],
	c_i: [8, 0],
	c_j: [9, 0],
	c_k: [10, 0],
	c_l: [11, 0],
	c_m: [12, 0],
	c_n: [13, 0],
	c_o: [14, 0],
	c_p: [15, 0],
	c_q: [16, 0],
	c_r: [17, 0],
	c_s: [18, 0],
	c_t: [0, 1],
	c_u: [1, 1],
	c_v: [2, 1],
	c_w: [3, 1],
	c_x: [4, 1],
	c_y: [5, 1],
	c_z: [6, 1],
	c_0: [7, 1],
	c_1: [8, 1],
	c_2: [9, 1],
	c_3: [10, 1],
	c_4: [11, 1],
	c_5: [12, 1],
	c_6: [13, 1],
	c_7: [14, 1],
	c_8: [15, 1],
	c_9: [16, 1],
	c_period: [17, 1],
	c_minus: [18, 1],
	c_plus: [18, 2],
	c_exclamation: [18, 3],
	c_colon: [17, 3],
	c_cash: [16, 2],
	c_lives: [17, 2]
};

function restart() {
	gamescreen = "mapselect";
	map = 0;
	money = 25;
	lives = 50;
	round = 0;
	towerNames = ["red regular", "blue bomber", "violet splasher", "amber tapper"];
	towerCost = [10, 25, 70, 95];
	towerDamage = [1, 2, 3, 5];
	towerRange = [4, 3, 2, 999];
	towerSpeed = [20, 30, 36, 24];
	towerTile = [[2, 4], [2, 6], [0, 8], [2, 8]];
	upgradeNames = ["heart monitor", "slime bombs", "fire flower", "auto clicker"];
	upgradeCost = [85, 100, 135, 250];
	upgradeDamage = [3, 4, 5, 9];
	upgradeRange = [6, 4, 3, 999];
	upgradeSpeed = [18, 25, 24, 8];
	
	towerData = []; // type, x, y, upgrade level, sell value, direction, cooldown
	
	path = [ // x, y, next direction: 0 right 1 down 2 left 3 up 4 finish
	[[1, 7, 0], [8, 7, 3], [8, 3, 0], [20, 3, 1], [20, 13, 2], [4, 13, 3], [4, 9, 0], [16, 9, 1], [16, 16, 4]],
	[[1, 14, 0], [5, 14, 3], [5, 11, 0], [11, 11, 1], [11, 12, 0], [17, 12, 3], [17, 3, 2], [15, 3, 1], [15, 5, 0], [22, 5, 3], [22, 2, 0], [24, 2, 4]],
	[[13, 0, 1], [13, 3, 2], [8, 3, 1], [8, 13, 0], [13, 13, 1], [13, 16, 4]],
	[[13, 16, 3], [13, 13, 0], [18, 13, 3], [18, 3, 2], [13, 3, 3], [13, 0, 4]]
	]; 
	
	canPlace = [ // sorry for the huge array
	[[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true],
	[true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, true, true, true],
	[true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true],
	[true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true],
	[true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true],
	[true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true]],
	
	[[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, false, true, true, true, true, false, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, true, true, true, true, true, true],
	[true, true, true, false, true, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true],
	[true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true]],
	
	[[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true],
	[true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true],
	[true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true]]
	];
	hoveringTower = -1;
	buyingTower = -1;
	selectedTower = -1;
	
	dotData = []; // hp, x, y, current speed mult, distance traveled, direction, path, target
	
	effectData = []; // type, x, y, lifespan
	
	autoStart = false;
	roundStarted = false;
	roundEnded = true;
	roundSpawns = [];
	roundData = [ // dot hp, amount, delay
	// standard: 1-10 hp
	// spider: 11-20 hp
	// flower: 21-30 hp
	// shell: 31-40 hp
	// gold: 41-50 hp
	// ruby: 51-100 hp
	// emerald: 101-200 hp
	// sapphire: 201-300 hp
	// amethyst: 301-400 hp
	// aquamarine: 401+ hp
	[[1, 12, 16], [1, 4, 2]], // 1
	[[1, 25, 4]], // 2
	[[1, 5, 5], [2, 10, 10], [1, 5, 5]], // 3
	[[3, 9, 6]], // 4
	[[5, 5, 5], [4, 8, 8], [3, 12, 12], [2, 16, 6], [1, 20, 1]], // 5
	[[1, 24, 4], [10, 1, 10]], // 6
	[[4, 10, 5], [5, 7, 10], [6, 4, 15]], // 7
	[[2, 25, 2], [3, 20, 3], [4, 15, 4]], // 8
	[[5, 20, 15], [6, 10, 5]], // 9
	[[20, 1, 20]], // 10
	[[7, 5, 10], [4, 20, 9], [5, 15, 8], [6, 10, 7]], // 11
	[[4, 18, 10], [6, 15, 11], [8, 12, 12]], // 12
	[[20, 1, 20], [9, 18, 9], [20, 1, 20]], // 13
	[[9, 15, 15], [6, 25, 2.5]], // 14
	[[20, 3, 18], [30, 1, 22]], // 15
	[[4, 24, 4], [30, 2, 20], [4, 24, 4]], // 16
	[[7, 46, 3], [20, 4, 17]], // 17
	[[10, 16, 7], [9, 16, 6], [8, 16, 5]], // 18
	[[5, 20, 5], [10, 14, 7.5], [20, 8, 10]], // 19
	[[40, 1, 40], [10, 9, 9]], // 20
	[[9, 27, 9], [30, 3, 15]], // 21
	[[10, 25, 2]], // 22
	[[30, 3, 10], [40, 4, 10]], // 23
	[[50, 1, 20], [5, 22, 2], [50, 1, 20]], // 24
	[[3, 28, 4], [5, 14, 5], [7, 13, 6], [9, 12, 7], [20, 11, 8]], // 25
	[[10, 7, 4], [40, 2, 20], [20, 6, 4]], // 26
	[[1, 200, 1], [4, 100, 2], [10, 25, 3], [40, 5, 4]], // 27
	[[50, 3, 7]], // 28
	[[30, 5, 6], [40, 3, 4]], // 29
	[[5, 12, 5], [20, 8, 5], [50, 4, 5]], // 30
	[[20, 5, 6], [30, 7, 8], [40, 7, 8]], // 31
	[[50, 1, 6], [40, 6, 5], [20, 8, 4]], // 32
	[[30, 20, 10]], // 33
	[[8, 95, 1], [40, 5, 2]], // 34
	[[30, 5, 6], [20, 20, 4], [10, 35, 2]], // 35
	[[9, 49, 1], [8, 51, 1], [7, 100, 0]], // 36
	[[10, 9, 6], [20, 8, 6], [30, 8, 4], [40, 9, 4]], // 37
	[[5, 37, 1], [7, 35, 1], [50, 12, 8], [9, 17, 2]], // 38
	[[20, 12, 4], [10, 11, 4], [50, 6, 4], [40, 11, 8], [30, 12, 8]], // 39
	[[50, 13, 5], [100, 2, 50]], // 40
	[[40, 16, 5], [30, 16, 5]], // 41
	[[30, 36, 4], [50, 14, 6]], // 42
	[[100, 1, 25], [40, 20, 10], [20, 20, 10], [100, 2, 25]], // 43
	[[10, 24, 1], [100, 2, 10], [20, 24, 2]], // 44
	[[10, 41, 2], [40, 21, 8], [400, 1, 80]], // 45
	[[300, 1, 30], [200, 2, 20], [100, 3, 10]], // 46
	[[20, 48, 2], [100, 4, 20], [30, 48, 2]], // 47
	[[40, 12, 8], [30, 12, 8], [40, 13, 4], [30, 13, 4]], // 48
	[[30, 30, 6], [40, 20, 4], [50, 10, 2]], // 49
	[[500, 1, 50], [1, 99, 0]], // 50
	[[50, 25, 4], [100, 10, 2]], // 51
	[[30, 27, 3], [40, 20, 6], [300, 3, 9]], // 52
	[[20, 47, 2], [200, 6, 7], [20, 47, 1]], // 53
	[[30, 10, 3], [400, 1, 80], [30, 13, 2], [400, 1, 80]], // 54
	[[40, 20, 3], [300, 5, 7]], // 55
	[[100, 20, 5], [50, 30, 5]], // 56
	[[400, 4, 40], [300, 3, 30], [200, 2, 20], [100, 1, 10]], // 57
	[[200, 10, 6], [50, 10, 4], [100, 10, 2]], // 58
	[[50, 20, 8], [40, 25, 6], [50, 30, 4]], // 59
	[[500, 5, 50]], // 60
	[[100, 10, 1], [20, 80, 2], [200, 10, 3]], // 61
	[[30, 20, 2], [20, 40, 1], [30, 80, 0], [300, 10, 10]], // 62
	[[300, 4, 10], [50, 24, 0], [300, 5, 10], [50, 25, 0], [300, 6, 10], [50, 26, 0]], // 63
	[[300, 19, 10], [400, 6, 20]], // 64
	[[40, 20, 4], [20, 40, 2], [200, 12, 6], [400, 16, 8]], // 65
	[[300, 10, 10], [200, 20, 10], [400, 10, 10]], // 66
	[[500, 1, 12], [300, 11, 11], [500, 2, 10]], // 67
	[[400, 20, 4]], // 68
	[[50, 40, 1], [20, 70, 0], [10, 100, -1]], // 69
	[[500, 10, 10]] // 70
	];
	totalDots = 0;
	
}

restart();
var fram = 0;
var last = 0;
var drawing = false;
var draw_x = 3;
var draw_y = 2;
var freeplay = [];
var freeplayRBE = 0;
var freeplayAmount = 0;
var freeplayDelay = 0;
var freeplayDot = 0;

// GAMEPLAY STUFF
function startRound() {
	dotTimer = 1;
	roundSpawns = [];
	if (roundData.length <= round) {
		freeplay = [];
		freeplayRBE = Math.pow(round, 2);
		while (freeplayRBE > 0) {
			freeplayDot = Math.floor(Math.random() * round / 20) * 100;
			if (freeplayDot < 100) {
				freeplayDot = 50;
			}
			freeplayAmount = Math.floor(Math.random() * (round * 15 / freeplayDot) + 5);
			freeplayDelay = (2000 / (round - 50)) / freeplayAmount;
			freeplay.push([freeplayDot, freeplayAmount, freeplayDelay]);
			freeplayRBE -= freeplayDot * freeplayAmount;
		}
		roundSpawns.push(freeplay);
	}
	else {
		roundSpawns.push(roundData[round]);
	}
	roundStarted = true;
	roundEnded = false;
	totalDots = 0;
	round++;
}

function towerSprite(_tower, _lvl, _d) {
	switch (_tower) {
		case 0:
		return [_d, 4+(_lvl >= 2)];
		break;
		case 1:
		return [_d, 6+(_lvl >= 2)];
		break;
		case 2:
		return [0, 8+(_lvl >= 2)];
		break;
		case 3:
		return [1+Math.floor(_d/2), 8+(_lvl >= 2)];
		break;
		default:
		break;
	}
}

function getTowerStats(_type, _lvl) {
	if (_lvl >= 2) {
		selectedDamage = upgradeDamage[_type];
		selectedRange = upgradeRange[_type];
		selectedSpeed = upgradeSpeed[_type];
	}
	else {
		selectedDamage = towerDamage[_type] + ((_type == 3) + 1) * _lvl;
		selectedRange = towerRange[_type] + _lvl;
		selectedSpeed = towerSpeed[_type];
	}
}

function getTowerStats2(_type, _lvl) {
	if (_lvl >= 2) {
		tempDamage = upgradeDamage[_type];
		tempRange = upgradeRange[_type];
		tempSpeed = upgradeSpeed[_type];
	}
	else {
		tempDamage = towerDamage[_type] + ((_type == 3) + 1) * _lvl;
		tempRange = towerRange[_type] + _lvl;
		tempSpeed = towerSpeed[_type];
	}
}

function dotSprite(_hp, _d) {
	if (_hp > 400) return [15, 8+_d]; // AQUAMARINE
	else if (_hp > 50) return [Math.ceil(_hp / 100 + 10), 8+_d]; // RUBY, EMERALD, SAPPHIRE, AMETHYST
	else if (_hp > 20) return [Math.ceil(_hp / 10 + 5), 8+_d]; // FLOWER, SHELL, GOLD
	else if (_hp > 10) return [18, 4+_d]; // SPIDER
	else if (_hp > 0) return [Math.ceil(_hp + 7), 4+_d]; // STANDARD
	else return [18, 11]; // NONE
}

function moveDots() {
	for (i = 0; i < dotData.length; i++) {
		dotSpeed = (dotData[i][0] >= 21) ? 5 / dotData[i][0] + 0.01 : dotData[i][0] / 100 + 0.1;
		dotData[i][4] += dotSpeed * dotData[i][3];
		switch (dotData[i][5]) {
			case 0: // right
			dotData[i][1] += dotSpeed * dotData[i][3];
			break;
			case 1: // down
			dotData[i][2] += dotSpeed * dotData[i][3];
			break;
			case 2: // left
			dotData[i][1] -= dotSpeed * dotData[i][3];
			break;
			case 3: // up
			dotData[i][2] -= dotSpeed * dotData[i][3];
			break;
		}
		if (Math.abs(dotData[i][1] - path[dotData[i][6]][dotData[i][7]][0]) <= dotSpeed * dotData[i][3] * 1.1 && Math.abs(dotData[i][2] - path[dotData[i][6]][dotData[i][7]][1]) <= dotSpeed * dotData[i][3] * 1.1) {
			dotData[i][1] = path[dotData[i][6]][dotData[i][7]][0];
			dotData[i][2] = path[dotData[i][6]][dotData[i][7]][1];
			dotData[i][7] += 1;
			dotData[i][5] = path[dotData[i][6]][dotData[i][7]-1][2];
		}
		if (dotData[i][0] >= 51 && dotData[i][0] <= 99) dotData[i][0] += 0.25; // RUBY
		else if (dotData[i][0] >= 101 && dotData[i][0] <= 200) dotData[i][3] = round / 35; // EMERALD
		if (dotData[i][3] <= round / 35) {
			dotData[i][3] += (round >= 50) ? round / 2000 : 0.02;
		}
		if (dotData[i][5] == 4) {
				lives -= dotData[i][0];
				dotData.splice(i, 1);
		}
		else if (dotData[i][0] <= 0) dotData.splice(i, 1);
	}
}

function checkImmunities(_tower, _level, _hp) {
	if (_hp > 400) return (_tower != 1 && _tower != 2); // AQUAMARINE
	else if (_hp > 40 && _hp <= 50) return (_tower != 0 && (_tower != 2 || _level >= 2)); // GOLD
	else if (_hp > 30 && _hp <= 40) return (_tower != 1); // SHELL
	else if (_hp > 20 && _hp <= 30) return (_tower != 2); // FLOWER
	else return true;
}

function damageReduction(_hp) {
	return ((_hp > 300) + 1) * ((_hp > 400) + 1) * ((_hp > 500) + 1); // SAPPHIRE -50%, AMETHYST -75%, AQUAMARINE -87.5%
}

function damageDot(_id, _amount) {
	if (dotData[_id][0] >= 0) {
		if (dotData[_id][0] <= _amount) {
			money += dotData[_id][0] / Math.pow(round - 0.6, 1.4);
		}
		else {
			money += _amount / Math.pow(round - 0.6, 1.4);
		}
	}
	dotData[_id][0] -= _amount;
	
	//if (dotData[_id][0] <= 0) {
		//dotData.splice(_id, 1);
	//}
}

function damageRadius(_x, _y, _amount, _range, _slime) {
	for (j = 0; j < dotData.length; j++) {
		if (distanceFrom(_x, _y, dotData[j][1], dotData[j][2]) <= _range && (checkImmunities(1, 0, dotData[j][0]))) {
			damageDot(j, _amount);
			if (_slime) {
				dotData[j][3] = 0.1;
			}
		}
	}
}

function distanceFrom(_x, _y, _x2, _y2) {
	return Math.sqrt(Math.pow(_x2 - _x, 2)+Math.pow(_y2 - _y, 2));
}

function pointTowards(_x, _y, _x2, _y2) {
	return Math.atan2(_x2 - _x, _y2 - _y)*180/Math.PI;
}

// MOUSE DETECTION

function canvas_move(_event) {
	xmouse = get_mouse_pos(activecanvas, _event, true).x;
	ymouse = get_mouse_pos(activecanvas, _event, true).y;
	switch (gamescreen) {
		case "mapselect":
		menuselect = -1;
		for (i = 10; i <= 12; i++) {
			if (touching(8, i, 17, i)) {
				menuselect = i - 10;
				map = i - 10;
			}
		}
		if (touching(8, 14, 18, 14)) menuselect = 3;
		break;
		case "help":
			touchtext = "";
			for (i = 0; i < 4; i++) {
				if (touching(0, i*3+4, 1, i*3+5)) {
					touchtext = towerNames[i];
				}
			}
		break;
		case "game":
			touchtext = "";
			if (buyingTower >= 0) {
				touchtext = towerNames[buyingTower];
			}
			else if (selectedTower >= 0) {
				touchtext = towerNames[towerData[selectedTower][0]];
			}
			hoveringTower = -1;
			for (i = 0; i < 4; i++) {
				if (touching(0, i*3+4, 1, i*3+5)) {
					touchtext = towerNames[i];
					hoveringTower = i;
				}
			}
			
		break;
	}
	
	//if (drawing) tile([draw_x, draw_y], xmouse, ymouse);
	
}


function canvas_click(_event) {
	console.log(get_mouse_pos(activecanvas, _event, true));
	//drawing = !drawing;
	
	switch (gamescreen) {
		case "mapselect":
		if (touching(8, 10, 17, 12)) gamescreen = "game";
		if (touching(8, 14, 18, 14)) gamescreen = "help";
		break;
		case "help":
		if (touching(14, 15, 15, 15)) gamescreen = "mapselect";
		else if (touching(16, 15, 17, 15) && dotPage > 0) dotPage--;
		else if (touching(22, 15, 23, 15) && dotPage < dotHP.length - 1) dotPage++;
		break;
		case "game":
		if (touching(23, 15, 24, 15) && lives <= 0) {
			gamescreen = "mapselect";
			restart();
		}			
		
		
		// START ROUND
		if (touching(22, 16, 23, 16)) {
			if (!roundStarted && roundEnded) startRound(); else autoStart = !autoStart;
		}
		
		if (buyingTower >= 0 && (xmouse >= 2 && xmouse <= 23 && ymouse >= 1 && ymouse <= 15) && canPlace[map][ymouse-1][xmouse-2] && money >= towerCost[buyingTower]) {
			towerData.push([buyingTower, xmouse, ymouse, 0, Math.floor(towerCost[buyingTower] * 0.75), 2, 0]);
			money -= towerCost[buyingTower];
			canPlace[map][ymouse-1][xmouse-2] = false;
			buyingTower = -1;
		}
		for (i = 0; i < 4; i++) {
		  if (touching(0, i*3+4, 1, i*3+5) && money >= towerCost[i]) buyingTower = i;
		}
		if (touching(0, 15, 1, 15)) { 
			buyingTower = -1;
		}
		if (ymouse <= 15) {
			selectedTower = -1;
		}
		else if (selectedTower >= 0) {
			// UPGRADE
			if (touching(5, 16, 8, 17) && towerData[selectedTower][3] <= 1 && selectedUpgradeCost >= 0 && money >= selectedUpgradeCost) {
				money -= selectedUpgradeCost;
				towerData[selectedTower][4] += selectedUpgradeCost * 0.75;
				towerData[selectedTower][3]++;
			}
			else if (touching(17, 17, 20, 17)) {
				money += towerData[selectedTower][4];
				canPlace[map][towerData[selectedTower][2]-1][towerData[selectedTower][1]-2] = true;
				towerData.splice(selectedTower, 1);
				selectedTower = -1;
			}
		}
		if (touching(22, 17, 23, 17)) gamespeed = 70 - gamespeed;
		for (i = 0; i < towerData.length; i++) {
			if (touching(towerData[i][1], towerData[i][2], towerData[i][1], towerData[i][2]) && buyingTower == -1) {
				selectedTower = i;
				touchtext = touchtext = towerNames[towerData[selectedTower][0]];
			}
		}
		break;
	}
}

function get_digit(_dig) {
	switch (_dig) {
		case " ":
		return "blank";
		break;
		case ".":
		return "c_period";
		break;
		case "-":
		return "c_minus";
		break;
		case "+":
		return "c_plus";
		break;
		case "!":
		return "c_exclamation";
		break;
		case ":":
		return "c_colon";
		break;
		case "$":
		return "c_cash";
		break;
		case "%":
		return "c_lives";
		break;
		default:
		return "c_"+_dig;
		break;
	}
}

function print(_text, _x, _y) {
	for (i = 0; i < _text.length; i++) {
		tile(sprites[get_digit(_text.charAt(i))], _x+i, _y);
	}
}

function get_mouse_pos(_canvas, _event, _grid) {
    var rect = _canvas.getBoundingClientRect();
    var scale_x = _canvas.width / rect.width;
    var scale_y = _canvas.height / rect.height;

    var pos = {
        x: (_event.clientX - rect.left) * scale_x,
		y: (_event.clientY - rect.top) * scale_y
    };
    
    if (!_grid) {
        return pos;
    }
    
    pos.x = Math.floor(pos.x/sprite_size);
    pos.y = Math.floor(pos.y/sprite_size);
	
    return pos;
}

function touching(_x1, _y1, _x2, _y2) {
	return ((xmouse >= _x1 && ymouse >= _y1) && (xmouse <= _x2 && ymouse <= _y2));
}

function tile(_tile, _x, _y) {
	activectx.drawImage(
        sprite_sheet,
        _tile[0]*sprite_size,
        _tile[1]*sprite_size,
        sprite_size,
        sprite_size,
        sprite_size*_x,
        sprite_size*_y,
        sprite_size,
        sprite_size
    );
}

canvas.addEventListener("mousemove", canvas_move, false);
canvas.addEventListener("click", canvas_click, false);
canvas2.addEventListener("mousemove", canvas_move, false);
canvas2.addEventListener("click", canvas_click, false);

function renderCanvas(_canvas, _ctx, _canvas2) {
	doneRendering = false;
	activecanvas = _canvas;
	activectx = _ctx;
	switch (gamescreen) {
		case "mapselect":
		
		_ctx.drawImage(maps[map], 0, 0);
		_ctx.drawImage(mapselectimage, 0, 0);
		
		if (menuselect >= 0 && menuselect <= 2) {
			print("hiscore: "+mapRecords[menuselect]+" "+mapRecordNames[menuselect], 3, 7);
		}
		
		switch (menuselect) {
			case 0:
			tile([0, 4], 6, 10);
			break;
			case 1:
			tile([0, 4], 6, 11);
			break;
			case 2:
			tile([0, 4], 6, 12);
			break;
			case 3:
			tile([0, 4], 6, 14);
			break;
		}
		break;
		case "help":
		_ctx.drawImage(helpimage, 0, 0);
		tile(dotSprite(dotHP[dotPage], 1), 19.5, 12);
		print(touchtext, 0, 0);
		
		print(dotNames[dotPage], 20 - dotNames[dotPage].length / 2, 14);
		print((dotHP[dotPage])+((dotHP[dotPage] >= 100) ? "hp" : " hp"), 17.55, 15);
		print(dotdesc[dotPage], 0, 16);
		print(dotdesc2[dotPage], 0, 17);
		
		/*print(": click to place", 0, 1);
		print(": on the map.", 0, 2);
		print("v", 0, 3);
		print("shoots once per sec.", 1, 4);
		print("monitor drains $+%.", 0, 5);
		print("hits multiple dots.", 1, 7);
		print("slime bombs slow them.", 0, 8);
		print("emits a pulse.", 1, 10);
		print("fire burns gold.", 0, 11);
		print("infinite range!", 1, 13);
		print("auto clicker", 0, 14);
		print("speeds up.", 2, 15);
		
		tile([15, 3], 13, 15);
		tile([16, 3], 14, 15);*/
		break;
		case "game":
		
		_ctx.drawImage(maps[map], 0, 0);
		
		// DRAW TOWERS
		for (i = 0; i < towerData.length; i++) {
			tile(towerSprite(towerData[i][0], towerData[i][3], towerData[i][5]), towerData[i][1], towerData[i][2]);
		}
		
		// DRAW DOTS
		for (i = 0; i < dotData.length; i++) {
			tile(dotSprite(dotData[i][0], dotData[i][5]), dotData[i][1], dotData[i][2]);
		}
		
		// DRAW EFFECTS
		for (i = 0; i < effectData.length; i++) {
			tile([(effectData[i][3] >= 4) ? 5 : 8 - effectData[i][3], 7 + effectData[i][0]], effectData[i][1], effectData[i][2]);
		}
		
		_ctx.drawImage(game_ui, 0, 0);
		print(touchtext, 0, 0);
		if (lives <= 0 && selectedTower == -1) {
			lives = 0;
			print("game over! ping me", 6, 16);
			print("on discord your score", 4, 17);
			tile([15, 3], 23, 15);
			tile([16, 3], 24, 15);
		}
		else if (round == 70 && !roundStarted && roundEnded && selectedTower == -1) {
			print("congrats! keep", 6, 16);
			print("going in freeplay", 5, 17);
		}
		print(Math.floor(money).toString(), 1, 16);
		print(Math.floor(lives).toString(), 1, 17);
		print("round "+round, 19-round.toString().length, 0);
		if (selectedTower >= 0 || buyingTower >= 0) {
			tile([13, 3], 0, 15);
			tile([14, 3], 1, 15);
			if (buyingTower >= 0) {
				tile(towerTile[buyingTower], xmouse, ymouse);
				_ctx.beginPath();
				_ctx.arc((xmouse + 0.5) * sprite_size, (ymouse + 0.5) * sprite_size, towerRange[buyingTower] * sprite_size, 0, 2 * Math.PI);
				_ctx.stroke();
			}
			
		}
		if (selectedTower >= 0) {
			// UPGRADE MENU
			getTowerStats(towerData[selectedTower][0], towerData[selectedTower][3]);
			tile([5, 3], 0, 1);
			tile([6, 3], 0, 2);
			tile([selectedDamage + 7, 1], 1, 1);
			tile((selectedRange >= 999) ? [7, 2] : [selectedRange + 7, 1], 1, 2);
			_ctx.beginPath();
			_ctx.arc((towerData[selectedTower][1] + 0.5) * sprite_size, (towerData[selectedTower][2] + 0.5) * sprite_size, selectedRange * sprite_size, 0, 2 * Math.PI);
			_ctx.stroke();
			switch (towerData[selectedTower][3]) {
				case 0:
				selectedUpgradeCost = Math.floor(towerCost[towerData[selectedTower][0]] / 2.5 + 12.5);
				tile([14, 2], 6, 17);
				print("base upgrade", 6, 16);
				print(selectedUpgradeCost.toString(), 7, 17);
				break;
				case 1:
				selectedUpgradeCost = upgradeCost[towerData[selectedTower][0]];
				tile([towerData[selectedTower][0]+7, 3], 6, 17);
				print(upgradeNames[towerData[selectedTower][0]], 6, 16);
				print(selectedUpgradeCost.toString(), 7, 17);
				break;
				default:
				selectedUpgradeCost = -1;
				break;
			}
			tile([11, 3], 17, 17);
			tile([12, 3], 18, 17);
			print(Math.floor(towerData[selectedTower][4]).toString(), 19, 17);
		}
		if (hoveringTower >= 0) {
			tile([5, 3], 0, 1);
			tile([6, 3], 0, 2);
			tile([towerDamage[hoveringTower] + 7, 1], 1, 1);
			tile((hoveringTower == 3) ? [7, 2] : [towerRange[hoveringTower] + 7, 1], 1, 2);
		}
		if (lives > 0) {
			tile([2 - (gamespeed <= 20) * 2, 11], 22, 17);
			tile([3 - (gamespeed <= 20) * 2, 11], 23, 17);
			if (autoStart) {
				tile([8, 2], 22, 16);
				tile([9, 2], 23, 16);
			}
			else if (!roundStarted && roundEnded) {
				tile([12, 2], 22, 16);
				tile([13, 2], 23, 16);
			}
			else {
				tile([10, 2], 22, 16);
				tile([11, 2], 23, 16);
			}
		}
		break;
	}
	doneRendering = true;
	_canvas.hidden = false;
	_canvas2.hidden = true;
}

var doneRendering = false;

function loop() {
	//ctx.clearRect(18, 9, canvas.width - 27, canvas.height - 27);
	
	// GAMEPLAY LOOP
	if (lives > 0) {
		
		// TOWER FUNCTIONALITY
		if (!roundEnded) {
			for (i = 0; i < towerData.length; i++) {
				towerData[i][6]--;
				if (towerData[i][6] <= 0) {
					// SEARCH FOR TARGET AND ATTACK
					getTowerStats2(towerData[i][0], towerData[i][3]);
					towerAttacked = false;
					towerCompare = -1;
					towerTarget = -1;
					if (towerData[i][0] == 2) { // VIOLET SPLASHER
						for (j = 0; j < dotData.length; j++) {
							if (distanceFrom(towerData[i][1], towerData[i][2], dotData[j][1], dotData[j][2]) <= tempRange) {
								if (checkImmunities(2, towerData[i][3], dotData[j][0])) {
									effectData.push([1, dotData[j][1] + (Math.random() - 0.5) / 2.5, dotData[j][2] + (Math.random() - 0.5) / 2.5, 4]);
									damageDot(j, tempDamage / damageReduction(dotData[j][0]));
								}
							}
						}
					}
					else {
						for (j = 0; j < dotData.length; j++) {
							if (dotData[j][4] >= towerCompare && distanceFrom(towerData[i][1], towerData[i][2], dotData[j][1], dotData[j][2]) <= tempRange) {
								towerCompare = dotData[j][4];
								towerTarget = j;
							}
						}
						if (towerTarget >= 0 && !towerAttacked) {
							if (checkImmunities(towerData[i][0], towerData[i][3], dotData[towerTarget][0])) {
								if (dotData[towerTarget] != null) {
									towerData[i][5] = Math.round(10 - (pointTowards(towerData[i][1], towerData[i][2], dotData[towerTarget][1], dotData[towerTarget][2])/45)) % 8;
								}
								if (towerData[i][0] == 1) { // BLUE BOMBER
									effectData.push([2, dotData[towerTarget][1] + (Math.random() - 0.5) / 2.5, dotData[towerTarget][2] + (Math.random() - 0.5) / 2.5, 4]);
									damageRadius(dotData[towerTarget][1], dotData[towerTarget][2], tempDamage / damageReduction(dotData[towerTarget][0]), 2, (towerData[i][3] >= 2));
								}
								else {
									if (towerData[i][0] == 0 && towerData[i][3] >= 2) { // HEART MONITOR
										money += 0.2;
										lives += 0.1;
									}
									effectData.push([1, dotData[towerTarget][1] + (Math.random() - 0.5) / 2.5, dotData[towerTarget][2] + (Math.random() - 0.5) / 2.5, 4]);
									damageDot(towerTarget, tempDamage / damageReduction(dotData[towerTarget][0]));
								}
							}
						}
					}
					towerData[i][6] = (towerData[i][3] >= 2) ? upgradeSpeed[towerData[i][0]] : towerSpeed[towerData[i][0]];
				}
			}
		}
		
		
		// DOT SPAWNING
		if (roundStarted && roundSpawns[0].length >= 1) {
			if (dotTimer <= 0) {
				totalDots++;
				dotData.push([roundSpawns[0][0][0], path[map+(map == 2 && totalDots % 2 == 0)][0][0], path[map+(map == 2 && totalDots % 2 == 0)][0][1], (round >= 35) ? round / 35 : 1, 0, path[map+(map == 2 && totalDots % 2 == 0)][0][2], map+(map == 2 && totalDots % 2 == 0), 1]);
				dotTimer = roundSpawns[0][0][2];
				roundSpawns[0][0][1]--;
				if (roundSpawns[0][0][1] <= 0) {
					roundSpawns[0].shift();
					if (roundSpawns[0].length <= 0) roundStarted = false;
				}
			}
			else {
				dotTimer--;
			}
		}
		else {
			if (!roundStarted && !roundEnded && dotData.length <= 0) {
				money += round * 2 - 2;
				if (autoStart) {
					roundStarted = true;
					roundEnded = false;
					startRound(); 
				}
				else {
					roundEnded = true;
				}
			}
		}
		moveDots();
		
		// EFFECTS
		for (i = 0; i < effectData.length; i++) {
			effectData[i][3]--;
			if (effectData[i][3] <= 0) {
				effectData.splice(i, 1);
			}
		}
	}
	
	// FPS
	var now = Date.now();
	fram += 2;
	  if (now - last >= 500) {
		  //fps = 1000 / (now - last);
		fps = fram;
		fram = 0;
		  last = now;
		console.log(fps);
	  }
	
	// RENDERING
	if (fps >= 10) {
		renderCanvas(canvas, ctx, canvas2);
		renderCanvas(canvas2, ctx2, canvas);
	}
	setTimeout(loop, gamespeed);
}

loop();</script>
</body>
</html>